<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Post-rsses on Plogging Dev</title>
    <link>https://www.ploggingdev.com/post/index.xml</link>
    <description>Recent content in Post-rsses on Plogging Dev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>ploggingdev@gmail.com (Plogging Dev)</managingEditor>
    <webMaster>ploggingdev@gmail.com (Plogging Dev)</webMaster>
    <lastBuildDate>Wed, 01 Mar 2017 07:38:58 -0800</lastBuildDate>
    <atom:link href="https://www.ploggingdev.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Quicksort</title>
      <link>https://www.ploggingdev.com/2017/03/quicksort/</link>
      <pubDate>Wed, 01 Mar 2017 07:38:58 -0800</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2017/03/quicksort/</guid>
      <description>&lt;p&gt;Quicksort is a divide and conquer algorithm. Quicksort first divides a large array into two smaller sub-arrays: the low elements and the high elements can then recursively sorts the sub-arrays.&lt;/p&gt;

&lt;p&gt;Quicksort is considered to one of the fastest general purpose sorting algorithms even today.&lt;/p&gt;

&lt;p&gt;Time complexity:&lt;/p&gt;

&lt;p&gt;Average case : &lt;strong&gt;n log n&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Best case : &lt;strong&gt;n log n&lt;/strong&gt; with simple partition&lt;/p&gt;

&lt;p&gt;Worst case : &lt;strong&gt;n&lt;sup&gt;2&lt;/sup&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;How does the algorithm work?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Pick an element, called a pivot, from the array.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Partitioning: reorder the array so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it (equal values can go either way). After this partitioning, the pivot is in its final position.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Recursively apply the above steps to the sub-array of elements with smaller values and separately to the sub-array of elements with greater values.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The base case of the recursion is arrays of size zero or one, which never need to be sorted.&lt;/p&gt;

&lt;p&gt;I will use the Hoare partition scheme for this implementation. It uses two indices that start at the ends of the array being partitioned, then move toward each other, until they detect an inversion: a pair of elements, one greater than or equal to the pivot, one lesser or equal, that are in the wrong order relative to each other. The inverted elements are then swapped. When the indices meet, the algorithm stops and returns the final index.&lt;/p&gt;

&lt;p&gt;Implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
def quicksort(to_sort, lo, hi):
    if lo &amp;lt; hi:
        p = partition(to_sort, lo, hi)
        quicksort(to_sort, lo, p)
        quicksort(to_sort, p + 1, hi)

def partition(to_sort, lo, hi):
    pivot = to_sort[lo]
    i = lo - 1
    j = hi + 1
    while True:
        
        i = i + 1
        while to_sort[i] &amp;lt; pivot:
            i = i + 1

        j = j - 1
        while to_sort[j] &amp;gt; pivot:
            j = j - 1

        if i &amp;gt;= j:
            return j
        
        temp = to_sort[i]
        to_sort[i] = to_sort[j]
        to_sort[j] = temp
    
if __name__ == &amp;quot;__main__&amp;quot;:
    to_sort = [1,3,2,0,-1,4,5,1,-2,-3,1,7]
    quicksort(to_sort, 0 ,len(to_sort)-1)
    print(to_sort)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[-3, -2, -1, 0, 1, 1, 1, 2, 3, 4, 5, 7]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;References/code:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Quicksort&#34;&gt;Wikipedia&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/ploggingdev/practice/blob/master/algos/quicksort.py&#34;&gt;quicksort.py&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/ploggingdev/practice/blob/master/algos/tests/quicksort_tests.py&#34;&gt;quicksort_tests.py&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Bubblesort</title>
      <link>https://www.ploggingdev.com/2017/03/bubblesort/</link>
      <pubDate>Wed, 01 Mar 2017 03:42:39 -0800</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2017/03/bubblesort/</guid>
      <description>&lt;p&gt;Bubble sort is a simple sorting algorithm that repeatedly steps through the list to be sorted, compares each pair of adjacent items and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted.&lt;/p&gt;

&lt;p&gt;Time complexity:&lt;/p&gt;

&lt;p&gt;Average case : &lt;strong&gt;n&lt;sup&gt;2&lt;/sup&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Worst case : &lt;strong&gt;n&lt;sup&gt;2&lt;/sup&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Best case : &lt;strong&gt;n&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Bubble sort is considered a very slow sorting algorithm and is mainly used in academic settings to illustrate time complexity with an example. One case where Bubble sort performs very well is when the list is already sorted. The best case has a time complexity of &lt;code&gt;n&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Implementation of Bubble sort:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def bubblesort(to_sort):
    list_len = len(to_sort)
    while list_len&amp;gt;0:
        new_n = 0
        for ix in range(1,list_len): #checks till n-1
            if to_sort[ix-1] &amp;gt; to_sort[ix]:
                temp = to_sort[ix-1]
                to_sort[ix-1] = to_sort[ix]
                to_sort[ix] = temp
                new_n = ix
        list_len = new_n
    return to_sort
    
if __name__ == &amp;quot;__main__&amp;quot;:
    to_sort = [1,3,2,0,-1,4,5]
    print(bubblesort(to_sort))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[-1, 0, 1, 2, 3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above implementation has an optimization : &lt;code&gt;new_n&lt;/code&gt; keeps track of the last index at which a swap occured and in the next iteration &lt;code&gt;list_len&lt;/code&gt; is set to &lt;code&gt;new_n&lt;/code&gt;, so if more than one value bubbles up to it&amp;rsquo;s correct position, there is no need to check if it&amp;rsquo;s in the correct position in the next iteration. (Ignore the poor naming of variables).&lt;/p&gt;

&lt;p&gt;References :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Bubble_sort&#34;&gt;Wikipedia&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/ploggingdev/practice/blob/master/algos/bubblesort.py&#34;&gt;bubblesort.py&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/ploggingdev/practice/blob/master/algos/tests/bubblesort_tests.py&#34;&gt;bubblesort_tests.py&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>FizzBuzz</title>
      <link>https://www.ploggingdev.com/2017/02/fizzbuzz/</link>
      <pubDate>Sun, 26 Feb 2017 02:04:45 -0800</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2017/02/fizzbuzz/</guid>
      <description>&lt;p&gt;What is the Fizz-Buzz test?&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s a programming interview question designed to filter out candidates who can&amp;rsquo;t program.&lt;/p&gt;

&lt;p&gt;Problem statement : Write a program that prints the numbers from 1 to 100. But for multiples of three print “Fizz” instead of the number and for the multiples of five print “Buzz”. For numbers which are multiples of both three and five print “FizzBuzz”.&lt;/p&gt;

&lt;p&gt;Out of curiousity, I decided to solve this problem.&lt;/p&gt;

&lt;p&gt;My first attempt :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for ix in range(1,101):
	if ix%3 == 0 and ix%5 == 0:
		print(&amp;quot;FizzBuzz&amp;quot;)
	elif ix%5 == 0:
		print(&amp;quot;Buzz&amp;quot;)
	elif ix%3 == 0:
		print(&amp;quot;Fizz&amp;quot;)
	else:
		print(ix)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Output after running &lt;code&gt;python3 sol1.py&lt;/code&gt; can be found &lt;a href=&#34;https://gist.github.com/ploggingdev/319de9494a9c7c7006c171413989eaa3&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The above code can be improved by removing redundant checking of divisibility by 3 and 5. Also important to note that FizzBuzz = Fizz + Buzz.&lt;/p&gt;

&lt;p&gt;Improved version :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for ix in range(1,101):
    res = &#39;&#39;
    if ix%3 == 0:
        res += &#39;Fizz&#39;
    if ix%5 == 0:
        res += &amp;quot;Buzz&amp;quot;
    print(res or ix)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let me explain the &lt;code&gt;print(res or ix)&lt;/code&gt; part : the &lt;code&gt;or&lt;/code&gt; operator is a short circuit operator, so &lt;code&gt;res&lt;/code&gt; is printed if it is not empty (it&amp;rsquo;s either a multiple of 3, 5 or both), otherwise &lt;code&gt;ix&lt;/code&gt; is printed.&lt;/p&gt;

&lt;p&gt;Links :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://wiki.c2.com/?FizzBuzzTest&#34;&gt;Source&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://blog.codinghorror.com/why-cant-programmers-program/&#34;&gt;Why Can&amp;rsquo;t Programmers.. Program?&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/ploggingdev/practice/blob/master/fizzbuzz/sol1.py&#34;&gt;sol1.py&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/ploggingdev/practice/blob/master/fizzbuzz/sol2.py&#34;&gt;sol2.py&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>concurrent.futures in Python 3</title>
      <link>https://www.ploggingdev.com/2017/01/concurrent.futures-in-python-3/</link>
      <pubDate>Thu, 12 Jan 2017 03:14:07 -0800</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2017/01/concurrent.futures-in-python-3/</guid>
      <description>&lt;p&gt;The concurrent.futures module provides a common high level interface for asynchronously executing callables using pools of threads or processes.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;concurrent.futures.Executor&lt;/code&gt; is a class to execute function calls asynchronously. The important methods are &lt;code&gt;submit(function, args)&lt;/code&gt;, which calls the specified function passing in the given arguments, and &lt;code&gt;map(function, iterables)&lt;/code&gt; which calls the specified function asynchronously passing in each iterable as an argument for a separate function call. This should not be used directly, but is used through its subclasses &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; and &lt;code&gt;ProcessPoolExecutor&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s jump into an example. The purpose of the following program is to find the sum of all prime numbers until the given number. There are two functions to demonstrate how to use a pool of threads and how to use a pool of processes. &lt;code&gt;sum_primes_thread(nums)&lt;/code&gt; uses threads and &lt;code&gt;sum_primes_process(nums)&lt;/code&gt; uses processes. Notice that the only difference between the two functions is that one uses &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; while the other uses &lt;code&gt;ProcessPoolExecutor&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import concurrent.futures
import time

def is_prime(num):
    if num &amp;lt;= 1:
        return False
    elif num &amp;lt;= 3:
        return True
    elif num%2 == 0 or num%3 == 0:
        return False
    i = 5
    while i*i &amp;lt;= num:
        if num%i == 0 or num%(i+2) == 0:
            return False
        i += 6
    return True

def find_sum(num):
    sum_of_primes = 0

    ix = 2

    while ix &amp;lt;= num:
        if is_prime(ix):
            sum_of_primes += ix
        ix += 1

    return sum_of_primes

def sum_primes_thread(nums):
    with concurrent.futures.ThreadPoolExecutor(max_workers = 4) as executor:
        for number, sum_res in zip(nums, executor.map(find_sum, nums)):
            print(&amp;quot;{} : Sum = {}&amp;quot;.format(number, sum_res))

def sum_primes_process(nums):
    with concurrent.futures.ProcessPoolExecutor(max_workers = 4) as executor:
        for number, sum_res in zip(nums, executor.map(find_sum, nums)):
            print(&amp;quot;{} : Sum = {}&amp;quot;.format(number, sum_res))

if __name__ == &#39;__main__&#39;:
    nums = [100000, 200000, 300000]
    start = time.time()
    sum_primes_thread(nums)
    print(&amp;quot;Time taken = {0:.5f}&amp;quot;.format(time.time() - start))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output when executing &lt;code&gt;sum_primes_process&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;100000 : Sum = 454396537
200000 : Sum = 1709600813
300000 : Sum = 3709507114
Time taken = 0.71783
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output when executing &lt;code&gt;sum_primes_thread&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;100000 : Sum = 454396537
200000 : Sum = 1709600813
300000 : Sum = 3709507114
Time taken = 1.23388
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This was a simple example to demonstrate how to use pools of threads and processes.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; : Don&amp;rsquo;t use threads for CPU intensive tasks.&lt;/p&gt;

&lt;p&gt;Though the callables themselves are executed asynchronously, the results are printed in the order they were called. The output can be displayed asynchronously also, as I demonstrate in the following example.&lt;/p&gt;

&lt;p&gt;This program just retrieves the titles of web pages.&lt;/p&gt;

&lt;p&gt;The output is displayed as and when a request is completed, so the order of the output usually changes between multiple runs of the program.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;concurrent.futures.as_completed(iterable_of_futures)&lt;/code&gt; method accepts an iterable of &lt;code&gt;Future&lt;/code&gt; objects. The iterable is a dictionary in this program, but other iterables can also be used (eg- list).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import concurrent.futures
import time
import requests
import bs4
import os

def load_url(current_url):
    res = requests.get(current_url)
    res.raise_for_status()

    current_page = bs4.BeautifulSoup(res.text,&amp;quot;html.parser&amp;quot;)
    current_title = current_page.select(&#39;title&#39;)[0].getText()
    return current_title

def process_urls_thread_alt(urls):
    with concurrent.futures.ThreadPoolExecutor(max_workers = 4) as executor:
        future_to_url = {executor.submit(load_url, url): url for url in urls}
        for future in concurrent.futures.as_completed(future_to_url):
            url = future_to_url[future]
            try:
                data = future.result()
            except Exception as exc:
                print(&#39;%r generated an exception: %s&#39; % (url, exc))
            else:
                print(&amp;quot;{} : Url = {}&amp;quot;.format(data, url))


def process_urls_process_alt(urls):
    with concurrent.futures.ProcessPoolExecutor(max_workers = 4) as executor:
        future_to_url = {executor.submit(load_url, url): url for url in urls}
        for future in concurrent.futures.as_completed(future_to_url):
            url = future_to_url[future]
            try:
                data = future.result()
            except Exception as exc:
                print(&#39;%r generated an exception: %s&#39; % (url, exc))
            else:
                print(&amp;quot;{} : Url = {}&amp;quot;.format(data, url))

if __name__ == &#39;__main__&#39;:
    url_list = [&amp;quot;https://www.google.com&amp;quot;, &amp;quot;https://www.ploggingdev.com/2016/11/beginning-python-3/&amp;quot;, &amp;quot;https://www.ploggingdev.com/archive/&amp;quot;, &amp;quot;https://www.ploggingdev.com/2016/11/data-types-in-python-3/&amp;quot;, &amp;quot;https://www.ploggingdev.com/2016/11/strings-in-python-3/&amp;quot;]
    start = time.time()
    process_urls_process_alt(url_list)
    print(&amp;quot;Time taken = {0:.5f}&amp;quot;.format(time.time() - start))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output of the program (same when using threads or processes):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Google : Url = https://www.google.com
Beginning Python 3 : Url = https://www.ploggingdev.com/2016/11/beginning-python-3/
Archive : Url = https://www.ploggingdev.com/archive/
Strings in Python 3 : Url = https://www.ploggingdev.com/2016/11/strings-in-python-3/
Data types in Python 3 : Url = https://www.ploggingdev.com/2016/11/data-types-in-python-3/
Time taken = 1.82259
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are three exceptions that can occur:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;concurrent.futures.CancelledError&lt;/code&gt; is raised when a future is cancelled&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;exception concurrent.futures.TimeoutError&lt;/code&gt; is raised when a future operation exceeds the given timeout&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;concurrent.futures.process.BrokenProcessPool&lt;/code&gt; is raised when one of the workers of a ProcessPoolExecutor has terminated in a non-clean fashion&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the above program they are handled in a catch all &lt;code&gt;except Exception&lt;/code&gt; block, but this can be modified depending on the requirements.&lt;/p&gt;

&lt;p&gt;Code for todays blog is &lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/concurrent_futures.py&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Reference : &lt;a href=&#34;https://docs.python.org/3/library/concurrent.futures.html&#34;&gt;Official library reference&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Multiprocessing and multithreading in Python 3</title>
      <link>https://www.ploggingdev.com/2017/01/multiprocessing-and-multithreading-in-python-3/</link>
      <pubDate>Mon, 09 Jan 2017 23:03:51 -0800</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2017/01/multiprocessing-and-multithreading-in-python-3/</guid>
      <description>&lt;p&gt;To begin with, let us clear up some terminlogy:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Concurrency is when two or more tasks can start, run, and complete in overlapping time periods. It doesn&amp;rsquo;t necessarily mean they&amp;rsquo;ll ever both be running at the same instant. Eg. multitasking on a single-core machine.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Parallelism is when two or more tasks are executed simultaneously.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A thread is a sequence of instructions within a process. It can be thought of as a lightweight process. Threads share the same memory space.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A process is an instance of a program running in a computer which can contain one or more threads. A process has its independant memory space.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;threading&lt;/code&gt; module is used for working with threads in Python.&lt;/p&gt;

&lt;p&gt;The CPython implementation has a Global Interpreter Lock (GIL) which allows only one thread to be active in the interpreter at once. This means that threads cannot be used for parallel execution of Python code. While parallel CPU computation is not possible, parallel IO operations are possible using threads. This is because performing IO operations releases the GIL. To learn more about the GIL refer &lt;a href=&#34;http://www.dabeaz.com/python/UnderstandingGIL.pdf&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;What are threads used for in Python?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;In GUI applications to keep the UI thread responsive&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;IO tasks (network IO or filesystem IO)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Threads should not be used for CPU bound tasks. Using threads for CPU bound tasks will actually result in worse performance compared to using a single thread.&lt;/p&gt;

&lt;p&gt;The following example demonstrates the use of threads for filesystem IO.&lt;/p&gt;

&lt;p&gt;A queue is used to store the files that need to be processed. A dictionary is used to store the input and output file names. The &lt;code&gt;process_queue()&lt;/code&gt; function is used to retrieve items from the queue and perform the copy operation. The copy operation is done in the &lt;code&gt;copy_op&lt;/code&gt; function using the &lt;code&gt;shutil&lt;/code&gt; module.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import threading
from queue import Queue
import time
import shutil

print_lock = threading.Lock()

def copy_op(file_data):
    with print_lock:
        print(&amp;quot;Starting thread : {}&amp;quot;.format(threading.current_thread().name))

    mydata = threading.local()
    mydata.ip, mydata.op = next(iter(file_data.items()))

    shutil.copy(mydata.ip, mydata.op)

    with print_lock:
        print(&amp;quot;Finished thread : {}&amp;quot;.format(threading.current_thread().name))

def process_queue():
    while True:
        file_data = compress_queue.get()
        copy_op(file_data)
        compress_queue.task_done()

compress_queue = Queue()

output_names = [{&#39;v1.mp4&#39; : &#39;v11.mp4&#39;},{&#39;v2.mp4&#39; : &#39;v22.mp4&#39;}]

for i in range(2):
    t = threading.Thread(target=process_queue)
    t.daemon = True
    t.start()

start = time.time()

for file_data in output_names:
    compress_queue.put(file_data)

compress_queue.join()

print(&amp;quot;Execution time = {0:.5f}&amp;quot;.format(time.time() - start))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note : The v1.mp4 and v2.mp4 were 250MB each.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7 to 10 seconds&lt;/strong&gt; was the time taken when using one thread&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.5 to 5.5 seconds&lt;/strong&gt; was the time taken when using two threads&lt;/p&gt;

&lt;p&gt;So it&amp;rsquo;s clear that threads can be used for parallel filesystem IO.&lt;/p&gt;

&lt;p&gt;The following example demonstrates the use of threads for network IO using the &lt;code&gt;requests&lt;/code&gt; library. This is a toy example use case of threads for networking IO.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import threading
from queue import Queue
import requests
import bs4
import time

print_lock = threading.Lock()

def get_url(current_url):

    with print_lock:
        print(&amp;quot;\nStarting thread {}&amp;quot;.format(threading.current_thread().name))
    res = requests.get(current_url)
    res.raise_for_status()

    current_page = bs4.BeautifulSoup(res.text,&amp;quot;html.parser&amp;quot;)
    current_title = current_page.select(&#39;title&#39;)[0].getText()

    with print_lock:
        print(&amp;quot;{}\n&amp;quot;.format(threading.current_thread().name))
        print(&amp;quot;{}\n&amp;quot;.format(current_url))
        print(&amp;quot;{}\n&amp;quot;.format(current_title))
        print(&amp;quot;\nFinished fetching : {}&amp;quot;.format(current_url))

def process_queue():
    while True:
        current_url = url_queue.get()
        get_url(current_url)
        url_queue.task_done()

url_queue = Queue()

url_list = [&amp;quot;https://www.google.com&amp;quot;]*5

for i in range(5):
    t = threading.Thread(target=process_queue)
    t.daemon = True
    t.start()

start = time.time()

for current_url in url_list:
    url_queue.put(current_url)

url_queue.join()

print(threading.enumerate())

print(&amp;quot;Execution time = {0:.5f}&amp;quot;.format(time.time() - start))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Single thread : &lt;strong&gt;4 seconds&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Two threads : &lt;strong&gt;3 seconds&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Five threads : &lt;strong&gt;2 seconds&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In network IO, most of the time is spent waiting for the response from the URL, so this is another use case where using threads improves performance.&lt;/p&gt;

&lt;p&gt;Let me demonstrate why it&amp;rsquo;s a bad idea to use threads for CPU bound tasks. In the following program a queue holds numbers. The task is to find the sum of prime number less than or equal to the given number. This is clearly a CPU bound task.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import threading
from queue import Queue
import time

list_lock = threading.Lock()

def find_rand(num):
    sum_of_primes = 0

    ix = 2

    while ix &amp;lt;= num:
        if is_prime(ix):
            sum_of_primes += ix
        ix += 1

    sum_primes_list.append(sum_of_primes)

def is_prime(num):
    if num &amp;lt;= 1:
        return False
    elif num &amp;lt;= 3:
        return True
    elif num%2 == 0 or num%3 == 0:
        return False
    i = 5
    while i*i &amp;lt;= num:
        if num%i == 0 or num%(i+2) == 0:
            return False
        i += 6
    return True

def process_queue():
    while True:
        rand_num = min_nums.get()
        find_rand(rand_num)
        min_nums.task_done()

min_nums = Queue()

rand_list = [1000000, 2000000, 3000000]
sum_primes_list = list()

for i in range(2):
    t = threading.Thread(target=process_queue)
    t.daemon = True
    t.start()

start = time.time()

for rand_num in rand_list:
    min_nums.put(rand_num)

min_nums.join()

end_time = time.time()

sum_primes_list.sort()
print(sum_primes_list)

print(&amp;quot;Execution time = {0:.5f}&amp;quot;.format(end_time - start))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Single thread : &lt;strong&gt;25.5 seconds&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Two threads : &lt;strong&gt;28 seconds&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The results are very clear : don&amp;rsquo;t use threads to improve performance of CPU bound tasks. You will always end up with worse performance.&lt;/p&gt;

&lt;p&gt;For parallel execution of tasks, the &lt;code&gt;multiprocessing&lt;/code&gt; module can be used.&lt;/p&gt;

&lt;p&gt;In the following example we take the same task used above and process the inputs in parallel using the &lt;code&gt;multiprocessing&lt;/code&gt; module.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from multiprocessing import Pool
import time

def sum_prime(num):
    
    sum_of_primes = 0

    ix = 2

    while ix &amp;lt;= num:
        if is_prime(ix):
            sum_of_primes += ix
        ix += 1

    return sum_of_primes

def is_prime(num):
    if num &amp;lt;= 1:
        return False
    elif num &amp;lt;= 3:
        return True
    elif num%2 == 0 or num%3 == 0:
        return False
    i = 5
    while i*i &amp;lt;= num:
        if num%i == 0 or num%(i+2) == 0:
            return False
        i += 6
    return True

if __name__ == &#39;__main__&#39;:
    start = time.time()
    with Pool(1) as p:
        print(p.map(sum_prime, [1000000, 2000000, 3000000]))
    print(&amp;quot;Time taken = {0:.5f}&amp;quot;.format(time.time() - start))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using a single process : &lt;strong&gt;27 seconds&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Using two processes : &lt;strong&gt;19 seconds&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Using three processes : &lt;strong&gt;18 seconds&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We see a huge improvement from using a single process to using two processes. But the jump from two processes to three processes is minimal. The reason behind this is my hardware. I have a dual core (laptop) CPU with hyperthreading (the OS detects it as four CPUs due to hyperthreading). On a side note, I knew Intel&amp;rsquo;s hyperthreading was not a replacement for more cores. The above example is a noob verification.&lt;/p&gt;

&lt;p&gt;So using the &lt;code&gt;multiprocessing&lt;/code&gt; module results in the full utilization of the CPU.&lt;/p&gt;

&lt;p&gt;Inter process communication can be achieved using queues or pipes. The &lt;code&gt;Queue&lt;/code&gt; in the &lt;code&gt;multiprocessing&lt;/code&gt; module works similar to the &lt;code&gt;queue&lt;/code&gt; module used to demonstrate how the &lt;code&gt;threading&lt;/code&gt; module works so I won&amp;rsquo;t cover it again.&lt;/p&gt;

&lt;p&gt;Another useful communication mechanism between processes is a pipe. A pipe is a duplex (two way) communication channel. Note : Reading or writing to the same end of the pipe simultaneously can result in data corruption.&lt;/p&gt;

&lt;p&gt;The following is a basic example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import multiprocessing as mp
import os

def info(conn):
    conn.send(&amp;quot;Hello from {}\nppid = {}\npid={}&amp;quot;.format(mp.current_process().name, os.getppid(), os.getpid()))
    conn.close()

if __name__ == &#39;__main__&#39;:

    parent_conn, child_conn = mp.Pipe()
    p = mp.Process(target=info, args=(child_conn,))
    p.daemon = True
    p.start()
    print(parent_conn.recv())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hello from Process-1
ppid = 18621
pid=18622
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Code:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/ploggingdev/python_learn/tree/master/multiprocess_demo&#34;&gt;Multiprocessing demo&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/ploggingdev/python_learn/tree/master/multithread_demo&#34;&gt;Multithreading demo&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.python.org/3/library/threading.html&#34;&gt;threading docs&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.python.org/3/library/multiprocessing.html&#34;&gt;multiprocessing docs&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.python.org/3/library/queue.html&#34;&gt;queue docs&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/1050222/concurrency-vs-parallelism-what-is-the-difference&#34;&gt;Stackoverflow question on Concurrency vs Parallelism&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.dabeaz.com/python/UnderstandingGIL.pdf&#34;&gt;Understanding the GIL&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Analyzing programming language statistics of 100,000 Github repositories</title>
      <link>https://www.ploggingdev.com/2016/12/analyzing-programming-language-statistics-of-100000-github-repositories/</link>
      <pubDate>Sun, 25 Dec 2016 23:03:21 -0800</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2016/12/analyzing-programming-language-statistics-of-100000-github-repositories/</guid>
      <description>&lt;p&gt;The first step is to gather data about 100,000 repositories using the Github api. I used &lt;code&gt;scrapy&lt;/code&gt; for this.&lt;/p&gt;

&lt;p&gt;A high level overview of how I did this:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Start from the id of my &lt;code&gt;scrape_github&lt;/code&gt; repo &lt;code&gt;https://api.github.com/repositories?since=76761293&amp;amp;access_token=MY_TOKEN&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Save only the &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;languages_url&lt;/code&gt; for each repo. The &lt;code&gt;languages_url&lt;/code&gt; is the api endpoint which contains the programming language statistics of the current repo.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Extract the link to the next page from the &lt;code&gt;Link&lt;/code&gt; header and follow it repeating the above steps.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Each api call returns a list of 100 repositories, so to retrieve data about 100,000 repositories, 1000 api calls are required.&lt;/p&gt;

&lt;p&gt;All the output is saved to a file called &lt;code&gt;all_repos.jsonl&lt;/code&gt; which came to around 13MB.&lt;/p&gt;

&lt;p&gt;The next step is to follow the &lt;code&gt;languages_url&lt;/code&gt; api endpoint for each repository and save the data.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;A high level overview of how I did this:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Read a line from &lt;code&gt;all_repos.jsonl&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Retrieve data from the &lt;code&gt;languages_url&lt;/code&gt; endpoint&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If an exception occurred, output an empty json object to &lt;code&gt;lang_data.jsonl&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Otherwise save the response to &lt;code&gt;lang_data.jsonl&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Check headers to see if api limit has been reached&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If api limit is reached, sleep until the api limit is reset&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Otherwise go to step 1 and repeat until all lines have been read&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There were a few HTTPError exceptions (returned HTTP 403 and 404 status codes) since Github blocked a few repositories for violating their Terms of Service. Around 3 such exceptions in the first 5000 repositories. There were also a lot of empty repositories.&lt;/p&gt;

&lt;p&gt;The api limit for Github is 5000 calls per hour. The headers include &lt;code&gt;X-RateLimit-Remaining&lt;/code&gt; which specifies how many api calls are remaining in the current hour. The &lt;code&gt;X-RateLimit-Reset&lt;/code&gt; header contains a number which specifies when the ratelimit will be reset. It is respresented as the seconds since the Unix epoch. These headers are used to check if the api limit has been reached and how much time to sleep for, if the limit has been reached.&lt;/p&gt;

&lt;p&gt;The total number of api calls made in this step is 100,000 which took a little over 20 hours to complete. I ran this in a VPS.&lt;/p&gt;

&lt;p&gt;Interesting to note that it takes around 5 minutes to make the 5000 api calls on the VPS. So the script is sleeping for the remaining 55+ minutes per hour. I took a screenshot of the bandwidth usage of the VPS the script was running on and it was nice to see a spike every hour (script is calling the Github api) and then go back to zero usage (script is sleeping) until the next spike. Here is the screenshot.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.ploggingdev.com/images/clockwork_code.png&#34; alt=&#34;Bandwidth usage over 24 hours&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Once all the relevant data was retrieved, the next step was to plot some graphs. Note that a single repository can include code using multiple programming languages.&lt;/p&gt;

&lt;p&gt;I was interested in the following data:&lt;/p&gt;

&lt;p&gt;Size of code vs programming language:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.ploggingdev.com/images/size_vs_lang.png&#34; alt=&#34;Size of code vs programming language&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Repos appeared in vs programming language:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.ploggingdev.com/images/repos_vs_lang.png&#34; alt=&#34;Repos appeared in vs programming language:&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Megabytes/repo vs programming language:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.ploggingdev.com/images/mb_per_repo_vs_lang.png&#34; alt=&#34;Megabytes/repo vs programming language:&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Take this data with a pinch of salt as it only represents the repositories created approximately over a 2 day perioid. Initially I planned to consider all repos created in 2016, but the sheer scale of Github made me rethink my plans. Extrapolating the number of repos created over 2 days to the the entire year, the number comes to around 18 million repos created in 2016. Besides, the point of the project was to learn a little about &lt;code&gt;scrapy&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here is the &lt;a href=&#34;https://github.com/ploggingdev/scrape_github&#34;&gt;code&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The installation instructions are on the readme file.&lt;/p&gt;

&lt;p&gt;The repo also includes the data I gathered from the github api:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/ploggingdev/scrape_github/blob/master/lang_data.jsonl&#34;&gt;lang_data.jsonl (3MB)&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/ploggingdev/scrape_github/blob/master/github_scraper/all_repos.jsonl&#34;&gt;all_repos.jsonl (13MB)&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Scraping my website using requests and BeautifulSoup</title>
      <link>https://www.ploggingdev.com/2016/12/scraping-my-website-using-requests-and-beautifulsoup/</link>
      <pubDate>Thu, 08 Dec 2016 04:48:07 -0800</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2016/12/scraping-my-website-using-requests-and-beautifulsoup/</guid>
      <description>&lt;p&gt;Ok, I didn&amp;rsquo;t use Scrapy because I am yet to go through it&amp;rsquo;s documentation. I will explore Scrapy in an upcoming blog post.&lt;/p&gt;

&lt;p&gt;Before getting to write code to scrape my website, I will cover the basics of the following modules:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;webbrowser&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;requests&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;BeautifulSoup&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;webbrowser&lt;/code&gt; module is a builtin module in Python . There is not a lot to explore in this module, except the &lt;code&gt;open(url)&lt;/code&gt; method. All it does is open the the default browser to a specified URL.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import webbrowser

urls = [&amp;quot;https://automatetheboringstuff.com/&amp;quot;, &amp;quot;https://automatetheboringstuff.com/chapter11/&amp;quot;]

for link in urls:
   webbrowser.open(link)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;The above code opens the links in the default browser. It should be noted that running the above code when no browser is open will cause an error message in Firefox. The message is something like &amp;ldquo;Firefox is already running&amp;rdquo;. This happens because the &lt;code&gt;webbrowser&lt;/code&gt; module detects that there is no browser open, and tries to open a new window for both links. Why both links? Probably because the second &lt;code&gt;webbrowser.open(url)&lt;/code&gt; method is called before the first call causes Firefox to start. How can this be avoided? A hacky solution is to use &lt;code&gt;time.sleep(n seconds)&lt;/code&gt; only after the first call to &lt;code&gt;webbrowser.open()&lt;/code&gt;. Another way is to just keep a Firefox window open, so all calls to &lt;code&gt;webbrowser.open()&lt;/code&gt; will open the link in a new tab. There are probably more elegant ways around this problem, let me know if you aware of any.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;requests&lt;/code&gt; library lets us make HTTP requests without worrying about network errors, connection problems, and data compression. It can make &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt;, and &lt;code&gt;delete&lt;/code&gt; requests among others.&lt;/p&gt;

&lt;p&gt;In the following example, &lt;code&gt;requests&lt;/code&gt; is used to get the homepage of this website and print some basic information about the response. The html response is saved to &lt;code&gt;mysite.html&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import requests

res = requests.get(&#39;https://www.ploggingdev.com&#39;)
res.raise_for_status()

#print(res.text)
print(&amp;quot;{} bytes&amp;quot;.format(len(res.text)))
print(&amp;quot;HTTP status code: {}&amp;quot;.format(res.status_code))
print(&amp;quot;response object type: {}&amp;quot;.format(type(res)))

mysite = open(&amp;quot;mysite.html&amp;quot;, &amp;quot;wb&amp;quot;)

print(&amp;quot;Writing the response content to mysite.html&amp;quot;)

for chunk in res.iter_content(10000):
    mysite.write(chunk)

mysite.close()

print(&amp;quot;Done writing&amp;quot;)

#output
11681 bytes
HTTP status code: 200
response object type: &amp;lt;class &#39;requests.models.Response&#39;&amp;gt;
Writing the response content to mysite.html
Done writing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some points to note:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;res.raise_for_status()&lt;/code&gt; is used to raise an exception if an error occurs while downloading&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;When writing the response html to a file, the file is opened in &lt;code&gt;wb&lt;/code&gt; mode to maintain the Unicode encoding of the text.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;res.iter_content(bytes)&lt;/code&gt; returns the specified number of bytes of the response content. This is useful when working with large responses.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you don&amp;rsquo;t already know about Unicode and character sets, read this &lt;a href=&#34;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&#34;&gt;post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Once the html content of a webpage has been retrieved, we need a library to parse the html. This is where &lt;code&gt;BeautifulSoup&lt;/code&gt; comes in.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;BeautifulSoup&lt;/code&gt; object is created by passing in html content. The html content can be in the form of &lt;code&gt;res.text&lt;/code&gt; using the &lt;code&gt;requests&lt;/code&gt; module or can be a text file.&lt;/p&gt;

&lt;p&gt;Briefly, &lt;code&gt;BeautifulSoup&lt;/code&gt; lets us:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;find elements in html using the &lt;code&gt;select()&lt;/code&gt; method. The selection can be made using html tags, ids. Additionally attributes can also be specified.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Data associated with an attribute can be retieved.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Learn more about how to use &lt;code&gt;BeautifulSoup&lt;/code&gt; by following the links at the end of this post.&lt;/p&gt;

&lt;p&gt;Coming to webscraping this website, what am I going to scrape? The url, title and keywords associated with every article.&lt;/p&gt;

&lt;p&gt;How will I accomplish this?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Hard code the url of the first blog post&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;create lists to hold urls, keywords and titles for every article&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Inside a &lt;code&gt;while True:&lt;/code&gt; loop, record the current blog url&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fetch the content hosted at the current blog url using &lt;code&gt;requests&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use &lt;code&gt;BeautifulSoup&lt;/code&gt; to parse the current page and extract the title and keywords for the current page&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Store the title and keywords for the current post&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;try to locate the link that leads to the next post and follow it&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;if the link to the next page is not found, it means that we have reached the latest blog and it&amp;rsquo;s time to stop scraping.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I added keywords to all blog posts recently and this will be an oppurtunity to check if the keywords have made it into all blogs. Why wouldn&amp;rsquo;t the keywords make it into the blogs if I added them? I use Hugo for this site. Sometimes if there is a typo while specifying the keywords (eg- an extra comma) then the &lt;code&gt;&amp;lt;meta name=&amp;quot;keywords&amp;quot;&lt;/code&gt; tag won&amp;rsquo;t be generated.&lt;/p&gt;

&lt;p&gt;Code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import requests
import bs4

print(&amp;quot;Fetching all blog posts&amp;quot;)

current_url = &#39;https://www.ploggingdev.com/2016/11/hello-world/&#39;

urls = list()
titles = list()
keywords = list()

while True:
    urls.append(current_url)

    res = requests.get(current_url)
    res.raise_for_status()

    current_page = bs4.BeautifulSoup(res.text,&amp;quot;html.parser&amp;quot;)
    
    current_title = current_page.select(&#39;title&#39;)[0].getText()
    titles.append(current_title)

    current_keywords = current_page.select(&#39;meta[name=&amp;quot;keywords&amp;quot;]&#39;)[0].get(&#39;content&#39;)
    keywords.append(current_keywords)

    #url for next blog post
    try:
        current_url = current_page.select(&#39;ul[class=&amp;quot;pager blog-pager&amp;quot;] &amp;gt; li[class=&amp;quot;next&amp;quot;] &amp;gt; a&#39;)[0].get(&#39;href&#39;)
    except IndexError as ie:
        break

#printing all my blog posts with urls. It&#39;s number from 1 to n

zipped = zip(range(1, len(urls)+1), titles, urls, keywords)

for blog_num, blog_title, blog_url, blog_keywords in zipped:
    print(blog_num)
    print(blog_title)
    print(blog_url)
    print(blog_keywords)
    print()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Fetching all blog posts
1
Hello World
https://www.ploggingdev.com/2016/11/hello-world/
plogging dev, hello world

2
Beginning Python 3
https://www.ploggingdev.com/2016/11/beginning-python-3/
python 3, Beginning python 3

3
Data types in Python 3
https://www.ploggingdev.com/2016/11/data-types-in-python-3/
python 3, beginning python 3, data types in python 3, datatypes in python 3, boolean in python 3, ints in p
ython 3, floats in python 3

4
Strings in Python 3
https://www.ploggingdev.com/2016/11/strings-in-python-3/
python 3, data types in python 3, datatypes in python 3, strings in python 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I won&amp;rsquo;t include the complete output here, but the program successfully scraped all the blog posts. You can find the output &lt;a href=&#34;https://gist.github.com/ploggingdev/343a0636e9696eac6799211d4f4385f8&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Code for today&amp;rsquo;s plog:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/webbrowser_demo.py&#34;&gt;Using webbrowser module&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/webscraping.py&#34;&gt;Code for requests and BeautifulSoup demo&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://automatetheboringstuff.com/chapter11/&#34;&gt;automatetheboringstuff&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://docs.python-requests.org/en/master/&#34;&gt;Requests docs&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.crummy.com/software/BeautifulSoup/bs4/doc/&#34;&gt;BeautifulSoup docs&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&#34;&gt;Unicode by Joel Spolsky&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Decorators in Python 3</title>
      <link>https://www.ploggingdev.com/2016/12/decorators-in-python-3/</link>
      <pubDate>Sun, 04 Dec 2016 22:29:11 -0800</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2016/12/decorators-in-python-3/</guid>
      <description>&lt;p&gt;A Python decorator is a specific change to the Python syntax that allows us to conveniently alter functions and methods. In simpler words, a decorator takes in a function, adds some functionality and returns it.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def my_decorator(func):
    def inner():
        print(&amp;quot;Decoration before function call&amp;quot;)
        func()
        print(&amp;quot;Decoration after function call&amp;quot;)

    return inner

@my_decorator
def simple_print():
    print(&amp;quot;Hello from simple_print&amp;quot;)

simple_print()
print()

#output
Decoration before function call
Hello from simple_print
Decoration after function call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;The function &lt;code&gt;my_decorator(func)&lt;/code&gt; is the decorator function. To use a decorator, place &lt;code&gt;@decorator_function_name&lt;/code&gt; before the function definition that you want to decorate.&lt;/p&gt;

&lt;p&gt;Doing the following&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@my_decorator
def simple_print():
    print(&amp;quot;Hello from simple_print&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is equivalent to doing&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def simple_print():
    print(&amp;quot;Hello from simple_print&amp;quot;)
simple_print = my_decorator(simple_print)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Decorators can also work with functions that accept arguments.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def check_valid_division(func):
    def inner(a,b):
        if b == 0:
            print(&amp;quot;Division by zero is not allowed&amp;quot;)
        else:
            func(a,b)
    
    return inner

@check_valid_division
def divide(a, b):
    print(a/b)

divide(10,5)
divide(10,0)

#output
2.0
Division by zero is not allowed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice how we decorated the &lt;code&gt;divide(a,b)&lt;/code&gt; function to prevent throwing a &lt;code&gt;ZeroDivisionError&lt;/code&gt; which would have been raised  if it was not decorated.&lt;/p&gt;

&lt;p&gt;It is also possible to chain multiple decorators together.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def print_star(func):
    def inner(val):
        print(&amp;quot;*&amp;quot; * 20)
        func(val)
        print(&amp;quot;*&amp;quot; * 20)
    
    return inner

def print_percent(func):
    def inner(val):
        print(&amp;quot;%&amp;quot; * 20)
        func(val)
        print(&amp;quot;%&amp;quot; * 20)
    
    return inner

@print_star
@print_percent
def fancy_print(val):
    print(val)

fancy_print(&amp;quot;Hello World&amp;quot;)
print()

@print_percent
@print_star
def fancy_print_different(val):
    print(val)

fancy_print_different(&amp;quot;Different decoration&amp;quot;)

#output
********************
%%%%%%%%%%%%%%%%%%%%
Hello World
%%%%%%%%%%%%%%%%%%%%
********************

%%%%%%%%%%%%%%%%%%%%
********************
Different decoration
********************
%%%%%%%%%%%%%%%%%%%%
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The syntax&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@print_star
@print_percent
def fancy_print(val):
    print(val)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def fancy_print(val):
    print(val)
fancy_print = print_star(print_percent(fancy_print))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Code for today&amp;rsquo;s plog is &lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/decorators.py&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.python.org/dev/peps/pep-0318/&#34;&gt;PEP 318&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.programiz.com/python-programming/decorator&#34;&gt;Programiz&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Performance measurement in Python 3</title>
      <link>https://www.ploggingdev.com/2016/12/performance-measurement-in-python-3/</link>
      <pubDate>Sat, 03 Dec 2016 21:13:22 -0800</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2016/12/performance-measurement-in-python-3/</guid>
      <description>&lt;p&gt;Performance measurement is the process of collecting and understanding information regarding the performance of some code.&lt;/p&gt;

&lt;p&gt;In this blog I will cover the basics of the following modules in Python:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;timeit&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;cProfile&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;pstats&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;memory_profiler&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;line_profiler&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;I will start with the &lt;code&gt;timeit&lt;/code&gt; module. This module enables us to time small pieces of code.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import timeit

res1 = timeit.timeit(&#39;&#39;&#39;
a = [i for i in range(50000)]
for i in a:
    pass
&#39;&#39;&#39;, number = 100)

res2 = timeit.timeit(&#39;&#39;&#39;
a = (i for i in range(50000))
for i in a:
    pass
&#39;&#39;&#39;, number = 100)

print(res1)

print(res2)

#output
0.26830113399955735
0.3227190840007097
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running &lt;code&gt;timeit.timeit(args)&lt;/code&gt; returns a float which represents the time taken to execute the given code. In the above example, the first argument is the code to be executed and the second argument is the number of times the code should be run. Executing the code multiple times and taking the average gives a more accurate result than running it a single time.&lt;/p&gt;

&lt;p&gt;Interestingly, the above example also demonstrates that list comprehensions are faster than using generator expressions to iterate over a range of values, but the memory consumption is higher which is not profiled in the above example.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;cProfile&lt;/code&gt; module provides deterministic profiling of a python program. Calling &lt;code&gt;cProfile.run(func_name, output_file_name)&lt;/code&gt; profiles the given function and writes the output to a specified file.&lt;/p&gt;

&lt;p&gt;The following columns are included in the output:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ncalls&lt;/code&gt; : for the number of calls&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;tottime&lt;/code&gt; : for the total time spent in the given function (and excluding time made in calls to sub-functions)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;percall&lt;/code&gt; : is the quotient of tottime divided by ncalls&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;cumtime&lt;/code&gt; : is the cumulative time spent in this and all subfunctions (from invocation till exit). This figure is accurate even for recursive functions&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;percall&lt;/code&gt; : is the quotient of cumtime divided by primitive calls&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;filename:lineno(function)&lt;/code&gt; : provides the respective data of each function&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;pstats.Stats&lt;/code&gt; class is used to read the profiled data and format the results as required.&lt;/p&gt;

&lt;p&gt;The following example profiles &lt;code&gt;to_be_profiled()&lt;/code&gt; and writes the profile data into the file called &lt;code&gt;cprofile_results&lt;/code&gt;. The &lt;code&gt;pstats.Stats&lt;/code&gt; class is then used to format the profile results in commonly used formats (check the comments in the program).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import cProfile
import pstats
import time
import sys

def to_be_profiled():
    my_list1 = [i**2 for i in range(50000)]

    my_list2 = (i**2 for i in range(100000, 150000))

    sum = 0

    print(&amp;quot;my_list1 = {} bytes&amp;quot;.format(sys.getsizeof(my_list1)))
    print(&amp;quot;my_list2 = {} bytes&amp;quot;.format(sys.getsizeof(my_list2)))

    for i in my_list2:
        sum += i
        time.sleep(0.00001)
        my_list1.append(i)
    print(sum)

cProfile.run(&#39;to_be_profiled()&#39;, &#39;cprofile_results&#39;)

p = pstats.Stats(&#39;cprofile_results&#39;)
#sort by standard name
p.strip_dirs().sort_stats(-1).print_stats(10)
#sort by function name
p.sort_stats(&#39;name&#39;).print_stats(10)
#sort by cumulative time in a function
p.sort_stats(&#39;cumulative&#39;).print_stats(10)
#sort by time spent in a function
p.sort_stats(&#39;time&#39;).print_stats(10)

#output
my_list1 = 406496 bytes
my_list2 = 88 bytes
791660416675000
Sat Dec  3 21:23:38 2016    cprofile_results

         150013 function calls in 3.580 seconds

   Ordered by: standard name
   List reduced from 11 to 10 due to restriction &amp;lt;10&amp;gt;

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.002    0.002    3.580    3.580 &amp;lt;string&amp;gt;:1(&amp;lt;module&amp;gt;)
        1    0.117    0.117    3.578    3.578 performance.py:23(to_be_profiled)
        1    0.014    0.014    0.014    0.014 performance.py:24(&amp;lt;listcomp&amp;gt;)
    50001    0.078    0.000    0.078    0.000 performance.py:26(&amp;lt;genexpr&amp;gt;)
        1    0.000    0.000    3.580    3.580 {built-in method builtins.exec}
        3    0.001    0.000    0.001    0.000 {built-in method builtins.print}
        2    0.000    0.000    0.000    0.000 {built-in method sys.getsizeof}
    50000    3.357    0.000    3.357    0.000 {built-in method time.sleep}
    50000    0.011    0.000    0.011    0.000 {method &#39;append&#39; of &#39;list&#39; objects}
        1    0.000    0.000    0.000    0.000 {method &#39;disable&#39; of &#39;_lsprof.Profiler&#39; objects}


Sat Dec  3 21:23:38 2016    cprofile_results

         150013 function calls in 3.580 seconds

   Ordered by: function name
   List reduced from 11 to 10 due to restriction &amp;lt;10&amp;gt;

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    3.580    3.580 {built-in method builtins.exec}
        3    0.001    0.000    0.001    0.000 {built-in method builtins.print}
        2    0.000    0.000    0.000    0.000 {built-in method sys.getsizeof}
    50000    3.357    0.000    3.357    0.000 {built-in method time.sleep}
    50001    0.078    0.000    0.078    0.000 performance.py:26(&amp;lt;genexpr&amp;gt;)
        1    0.014    0.014    0.014    0.014 performance.py:24(&amp;lt;listcomp&amp;gt;)
    50000    0.011    0.000    0.011    0.000 {method &#39;append&#39; of &#39;list&#39; objects}
        1    0.000    0.000    0.000    0.000 {method &#39;disable&#39; of &#39;_lsprof.Profiler&#39; objects}
        2    0.000    0.000    0.000    0.000 {method &#39;format&#39; of &#39;str&#39; objects}
        1    0.002    0.002    3.580    3.580 &amp;lt;string&amp;gt;:1(&amp;lt;module&amp;gt;)

Sat Dec  3 21:23:38 2016    cprofile_results

         150013 function calls in 3.580 seconds

   Ordered by: cumulative time
   List reduced from 11 to 10 due to restriction &amp;lt;10&amp;gt;

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    3.580    3.580 {built-in method builtins.exec}
        1    0.002    0.002    3.580    3.580 &amp;lt;string&amp;gt;:1(&amp;lt;module&amp;gt;)
        1    0.117    0.117    3.578    3.578 performance.py:23(to_be_profiled)
    50000    3.357    0.000    3.357    0.000 {built-in method time.sleep}
    50001    0.078    0.000    0.078    0.000 performance.py:26(&amp;lt;genexpr&amp;gt;)
        1    0.014    0.014    0.014    0.014 performance.py:24(&amp;lt;listcomp&amp;gt;)
    50000    0.011    0.000    0.011    0.000 {method &#39;append&#39; of &#39;list&#39; objects}
        3    0.001    0.000    0.001    0.000 {built-in method builtins.print}
        2    0.000    0.000    0.000    0.000 {built-in method sys.getsizeof}
        2    0.000    0.000    0.000    0.000 {method &#39;format&#39; of &#39;str&#39; objects}

Sat Dec  3 21:23:38 2016    cprofile_results

         150013 function calls in 3.580 seconds

   Ordered by: internal time
   List reduced from 11 to 10 due to restriction &amp;lt;10&amp;gt;

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
    50000    3.357    0.000    3.357    0.000 {built-in method time.sleep}
        1    0.117    0.117    3.578    3.578 performance.py:23(to_be_profiled)
    50001    0.078    0.000    0.078    0.000 performance.py:26(&amp;lt;genexpr&amp;gt;)
        1    0.014    0.014    0.014    0.014 performance.py:24(&amp;lt;listcomp&amp;gt;)
    50000    0.011    0.000    0.011    0.000 {method &#39;append&#39; of &#39;list&#39; objects}
        1    0.002    0.002    3.580    3.580 &amp;lt;string&amp;gt;:1(&amp;lt;module&amp;gt;)
        3    0.001    0.000    0.001    0.000 {built-in method builtins.print}
        1    0.000    0.000    3.580    3.580 {built-in method builtins.exec}
        2    0.000    0.000    0.000    0.000 {built-in method sys.getsizeof}
        2    0.000    0.000    0.000    0.000 {method &#39;format&#39; of &#39;str&#39; objects}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Moving on to the &lt;code&gt;memory_profiler&lt;/code&gt;, the installation procedure is as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#install memory_profiler module
pip install memory_profiler

#install psutil

pip install psutil

#install matplotlib
pip install matplotlib

sudo apt-get install python3-matplotlib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To install &lt;code&gt;matplotlib&lt;/code&gt;, I first tried &lt;code&gt;pip install matplotlib&lt;/code&gt;, but I was still facing issues plotting graphs. Then I tried, &lt;code&gt;sudo apt-get install python-matplotlib&lt;/code&gt; which installed &lt;code&gt;matplotlib&lt;/code&gt; for Python 2. Finally I tried &lt;code&gt;sudo apt-get install python3-matplotlib&lt;/code&gt; and was able to plot graphs. So my installation procedure installed a lot of unnecessay modules and packages.&lt;/p&gt;

&lt;p&gt;To see a line by line memory profile of a function, the &lt;code&gt;memory_profiler&lt;/code&gt; is used. Importing is done using &lt;code&gt;from memory_profiler import profile&lt;/code&gt;. To specify which function needs to be memory profiled, use the &lt;code&gt;@profile&lt;/code&gt; decorator.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import sys
import cProfile
from memory_profiler import profile

@profile()
def mem_to_be_profiled():
    
    my_list1 = [i**2 for i in range(50000)]

    my_list2 = (i**2 for i in range(100000, 150000))

    sum = 0

    print(&amp;quot;my_list1 = {} bytes&amp;quot;.format(sys.getsizeof(my_list1)))
    print(&amp;quot;my_list2 = {} bytes&amp;quot;.format(sys.getsizeof(my_list2)))

    for i in my_list2:
        sum += i
        my_list1.append(i)
    print(sum)

mem_to_be_profiled()

#output
my_list1 = 406496 bytes
my_list2 = 88 bytes
791660416675000
Filename: mem.py

Line #    Mem usage    Increment   Line Contents
================================================
     5     30.4 MiB      0.0 MiB   @profile()
     6                             def mem_to_be_profiled():
     7
     8     32.1 MiB      1.7 MiB       my_list1 = [i**2 for i in range(50000)]
     9
    10     34.8 MiB      2.7 MiB       my_list2 = (i**2 for i in range(100000, 150000))
    11
    12     32.1 MiB     -2.7 MiB       sum = 0
    13
    14     32.1 MiB      0.0 MiB       print(&amp;quot;my_list1 = {} bytes&amp;quot;.format(sys.getsizeof(my_list1)))
    15     32.1 MiB      0.0 MiB       print(&amp;quot;my_list2 = {} bytes&amp;quot;.format(sys.getsizeof(my_list2)))
    16
    17     34.8 MiB      2.7 MiB       for i in my_list2:
    18     34.8 MiB      0.0 MiB           sum += i
    19     34.8 MiB      0.0 MiB           my_list1.append(i)
    20     34.8 MiB      0.0 MiB       print(sum)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I was hoping to demonstrate that list comprehensions use more memory than generator expressions using memory profiling, but for some reason &lt;code&gt;2.7 MB&lt;/code&gt; of memory is allocated during the creation of a generator object and then it&amp;rsquo;s immediately released in the next line. If you know why this happens everytime, let me know in the comments.&lt;/p&gt;

&lt;p&gt;Now comes the interesting part: plotting a graph of memory usage vs time. We will use the &lt;code&gt;mprof&lt;/code&gt; executable for this.&lt;/p&gt;

&lt;p&gt;Run the script and collect memory profile data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mprof run mem.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above command stores the result in a file in the current directory.&lt;/p&gt;

&lt;p&gt;Plot a graph of memory usage vs time:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mprof plot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above command uses the most recently generated memory profile data.&lt;/p&gt;

&lt;p&gt;Output screenshot:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.ploggingdev.com/images/mem_profile.png&#34; alt=&#34;Memory profile graph&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Next I will cover the &lt;code&gt;line_profiler&lt;/code&gt; module.&lt;/p&gt;

&lt;p&gt;Installation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install line_profiler
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use the &lt;code&gt;@profile&lt;/code&gt; decorator to specify the function that needs to be profiled.&lt;/p&gt;

&lt;p&gt;Running the script directly using &lt;code&gt;python file.py&lt;/code&gt; throws an error since &lt;code&gt;@profile&lt;/code&gt; is not defined,&lt;/p&gt;

&lt;p&gt;To see the line by line profile of the function, use :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kernprof -l -v line.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are ways to get around this issue and run it as a normal script as well as profiling it using &lt;code&gt;kernprof&lt;/code&gt;. Here is a &lt;a href=&#34;http://stackoverflow.com/questions/18229628/python-profiling-using-line-profiler-clever-way-to-remove-profile-statements&#34;&gt;Stackoverflow answer&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import sys

@profile
def to_be_profiled():
    
    my_list1 = [i**2 for i in range(50000)]

    my_list2 = (i**2 for i in range(100000, 150000))
    sum = 0
    print(&amp;quot;my_list1 = {} bytes&amp;quot;.format(sys.getsizeof(my_list1)))
    print(&amp;quot;my_list2 = {} bytes&amp;quot;.format(sys.getsizeof(my_list2)))

    for i in my_list2:
        sum += i
        my_list1.append(i)
    print(sum)


to_be_profiled()

#output
my_list1 = 406496 bytes
my_list2 = 88 bytes
791660416675000
Wrote profile results to line.py.lprof
Timer unit: 1e-06 s

Total time: 0.17311 s
File: line.py
Function: to_be_profiled at line 3

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     3                                           @profile
     4                                           def to_be_profiled():
     5
     6         1        17575  17575.0     10.2      my_list1 = [i**2 for i in range(50000)]
     7
     8         1            7      7.0      0.0      my_list2 = (i**2 for i in range(100000, 150000))
     9         1            1      1.0      0.0      sum = 0
    10         1           43     43.0      0.0      print(&amp;quot;my_list1 = {} bytes&amp;quot;.format(sys.getsizeof(my_li
st1)))
    11         1           24     24.0      0.0      print(&amp;quot;my_list2 = {} bytes&amp;quot;.format(sys.getsizeof(my_li
st2)))
    12
    13     50001        68438      1.4     39.5      for i in my_list2:
    14     50000        42867      0.9     24.8          sum += i
    15     50000        44122      0.9     25.5          my_list1.append(i)
    16         1           33     33.0      0.0      print(sum)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I only covered the basic usage of the performance measurement modules, to learn more refer to the links below.&lt;/p&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.python.org/3/library/timeit.html#module-timeit&#34;&gt;timeit module&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.python.org/3/library/profile.html&#34;&gt;cProfile and pstats&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://pypi.python.org/pypi/memory_profiler&#34;&gt;memory_profiler&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/rkern/line_profiler&#34;&gt;line_profiler&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Code for today&amp;rsquo;s plog:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/performance.py&#34;&gt;performance.py&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/mem.py&#34;&gt;mem.py&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/line.py&#34;&gt;line.py&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/requirements.txt&#34;&gt;requirements.txt has been updated&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>List comprehensions, iterators, generators and generator expressions in Python 3</title>
      <link>https://www.ploggingdev.com/2016/12/list-comprehensions-iterators-generators-and-generator-expressions-in-python-3/</link>
      <pubDate>Fri, 02 Dec 2016 20:54:31 -0800</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2016/12/list-comprehensions-iterators-generators-and-generator-expressions-in-python-3/</guid>
      <description>&lt;p&gt;A list comprehension is a concise way to create lists that would normally require &lt;code&gt;for&lt;/code&gt; loops to build.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list1 = [x**2 for x in range(10)]
print(list1)
#output
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;List comprehension to create a list of tuples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list2 = [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
print(list2)
#output
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;List comprehension using an &lt;code&gt;if&lt;/code&gt; condition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list3 = [x for x in range(10) if x%2 != 0]
print(list3)
#output
[1, 3, 5, 7, 9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Only odd numbers are printed in the above example.&lt;/p&gt;

&lt;p&gt;Nested list comprehensions allow us to emulate nested &lt;code&gt;for&lt;/code&gt; loops in some way.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;matrix = [
    [1,2,3],
    [4,5,6],
    [7,8,9],
    [10,11,12]
]

transposed = [[row[i] for row in matrix] for i in range(3)]
print(transposed)
#output
[[1, 4, 7, 10], [2, 5, 8, 11], [3, 6, 9, 12]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The equivalent using nested &lt;code&gt;for&lt;/code&gt; loops would be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i in range(3):
    transposed.append([row[i] for row in matrix])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Moving on to iterators. Iterators let us iterate over container objects using &lt;code&gt;for&lt;/code&gt; loops. How to create an iterator: create a class which defines &lt;code&gt;__iter__()&lt;/code&gt; and &lt;code&gt;__next__()&lt;/code&gt;. &lt;code&gt;__iter__()&lt;/code&gt; returns an object with a &lt;code&gt;__next__()&lt;/code&gt; method. The &lt;code&gt;__next__()&lt;/code&gt; method which is used to retrieve the next object in the container. The &lt;code&gt;__next__()&lt;/code&gt; method will also need to raise a &lt;code&gt;StopIteration&lt;/code&gt; exception when there are no more elements to iterate over.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Squared:
    &amp;quot;&amp;quot;&amp;quot;Square all the numbers&amp;quot;&amp;quot;&amp;quot;

    def __init__(self, data):
        self.data = data
        self.index = 0
    
    def __iter__(self):
        return self

    def __next__(self):
        if self.index == len(self.data):
            raise StopIteration
        val = self.data[self.index] **2
        self.index += 1

        return val

values = Squared([1,2,3,10])

for i in values:
    print(i)

#output
1
4
9
100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generators are a way to create iterators. There is no need to explicitly define the &lt;code&gt;__iter__()&lt;/code&gt; and &lt;code&gt;__next__()&lt;/code&gt; methods, they are created automatically. Generators are functions that use the &lt;code&gt;yield&lt;/code&gt; statement to return data. When &lt;code&gt;__next__()&lt;/code&gt; is called, the function resumes where it left off and remembers the state of the program. The &lt;code&gt;StopIteration&lt;/code&gt; exception is also automatically raised.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def double_values(data):
    &amp;quot;&amp;quot;&amp;quot;Doubles all the values&amp;quot;&amp;quot;&amp;quot;
    for val in data:
        yield val*2

for i in double_values([4,5,3]):
    print(i)

#output
8
10
6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generator expressions are a simple but limited way to create generators and used in cases where the return value of the generator expression is used immediately. They have a syntax similar to list comprehensions, but use parantheses instead of brackets.&lt;/p&gt;

&lt;p&gt;Since generator expressions &lt;em&gt;generate&lt;/em&gt; the values on the fly instead of storing all the values in memory like list comprehensions do, they tend to be more memory efficient than the equivalent list comprehension but also tend to be a little slower. This is an important tradeoff to keep in mind.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exp = sum(i for i in range(5))
print(exp)

#output
10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Source code for today&amp;rsquo;s plog is &lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/generators.py&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.python.org/3/tutorial/datastructures.html#more-on-lists&#34;&gt;List comprehensions&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.python.org/3/tutorial/classes.html#iterators&#34;&gt;Generators, iterators and generator expressions&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>N queens solver in Python 3</title>
      <link>https://www.ploggingdev.com/2016/11/n-queens-solver-in-python-3/</link>
      <pubDate>Wed, 30 Nov 2016 04:14:07 -0800</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2016/11/n-queens-solver-in-python-3/</guid>
      <description>&lt;p&gt;What is the N queens problem?&lt;/p&gt;

&lt;p&gt;The N queens problem is the problem of placing N non-attacking queens on an NxN chessboard, for which solutions exist for all natural numbers N with the exception of N=2 and N=3.&lt;/p&gt;

&lt;p&gt;When N=1, the solution is trivial so the program will ask for a value of N such that &lt;code&gt;N &amp;gt;= 4&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I will solve this problem using backtracking. There are more efficient ways to solve this problem, but I will use backtracking since it&amp;rsquo;s the most intuitive way to arrive at the solution without getting into the mathematics of arriving at efficient solutions. Through solving these problems, I aim to better understand Python.&lt;/p&gt;

&lt;p&gt;What is backtracking?&lt;/p&gt;

&lt;p&gt;Backtracking is a general algorithm for finding all (or some) solutions to some computational problems, notably constraint satisfaction problems, that incrementally builds candidates to the solutions, and abandons each partial candidate &lt;em&gt;c&lt;/em&gt; (&amp;ldquo;backtracks&amp;rdquo;) as soon as it determines that &lt;em&gt;c&lt;/em&gt; cannot possibly be completed to a valid solution.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;A high level overview of how to use backtracking to solve the N queens problem:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;place a queen in the first column and first row&lt;/li&gt;
&lt;li&gt;place a queen in the second column such that it does not attack the queen in the first column&lt;/li&gt;
&lt;li&gt;continue placing non-attacking queens in the remaining columns&lt;/li&gt;
&lt;li&gt;if all N queens have been placed, a solution has been found. Remove the queen in the Nth column, and try incrementing the row of the queen in the (N-1)th column&lt;/li&gt;
&lt;li&gt;if it&amp;rsquo;s a dead end, remove the queen, increment the row of the queen in the previous column&lt;/li&gt;
&lt;li&gt;continue doing this until the queen in the 1st column exhausts all options and is in the row N&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The above explanation starts counting at 1, not 0 based counting.&lt;/p&gt;

&lt;p&gt;To see a visualization of backtracking, refer &lt;a href=&#34;https://en.wikipedia.org/wiki/Eight_queens_puzzle#Exercise_in_algorithm_design&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The solution:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import copy

def take_input():
    &amp;quot;&amp;quot;&amp;quot;Accepts the size of the chess board&amp;quot;&amp;quot;&amp;quot;

    while True:
        try:
            size = int(input(&#39;What is the size of the chessboard? n = \n&#39;))
            if size == 1:
                print(&amp;quot;Trivial solution, choose a board size of atleast 4&amp;quot;)
            if size &amp;lt;= 3:
                print(&amp;quot;Enter a value such that size&amp;gt;=4&amp;quot;)
                continue
            return size
        except ValueError:
            print(&amp;quot;Invalid value entered. Enter again&amp;quot;)

def get_board(size):
    &amp;quot;&amp;quot;&amp;quot;Returns an n by n board&amp;quot;&amp;quot;&amp;quot;
    board = [0]*size
    for ix in range(size):
        board[ix] = [0]*size
    return board

def print_solutions(solutions, size):
    &amp;quot;&amp;quot;&amp;quot;Prints all the solutions in user friendly way&amp;quot;&amp;quot;&amp;quot;
    for sol in solutions:
        for row in sol:
            print(row)
        print()
            
def is_safe(board, row, col, size):
    &amp;quot;&amp;quot;&amp;quot;Check if it&#39;s safe to place a queen at board[x][y]&amp;quot;&amp;quot;&amp;quot;

    #check row on left side
    for iy in range(col):
        if board[row][iy] == 1:
            return False
    
    ix, iy = row, col
    while ix &amp;gt;= 0 and iy &amp;gt;= 0:
        if board[ix][iy] == 1:
            return False
        ix-=1
        iy-=1
    
    jx, jy = row,col
    while jx &amp;lt; size and jy &amp;gt;= 0:
        if board[jx][jy] == 1:
            return False
        jx+=1
        jy-=1
    
    return True

def solve(board, col, size):
    &amp;quot;&amp;quot;&amp;quot;Use backtracking to find all solutions&amp;quot;&amp;quot;&amp;quot;
    #base case
    if col &amp;gt;= size:
        return
    
    for i in range(size):
        if is_safe(board, i, col, size):
            board[i][col] = 1
            if col == size-1:
                add_solution(board)
                board[i][col] = 0
                return
            solve(board, col+1, size)
            #backtrack
            board[i][col] = 0

def add_solution(board):
    &amp;quot;&amp;quot;&amp;quot;Saves the board state to the global variable &#39;solutions&#39;&amp;quot;&amp;quot;&amp;quot;
    global solutions
    saved_board = copy.deepcopy(board)
    solutions.append(saved_board)

size = take_input()

board = get_board(size)

solutions = []

solve(board, 0, size)

print_solutions(solutions, size)

print(&amp;quot;Total solutions = {}&amp;quot;.format(len(solutions)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output of the program when N=4:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;What is the size of the chessboard? n = 
4
[0, 0, 1, 0]
[1, 0, 0, 0]
[0, 0, 0, 1]
[0, 1, 0, 0]

[0, 1, 0, 0]
[0, 0, 0, 1]
[1, 0, 0, 0]
[0, 0, 1, 0]

Total solutions = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some important takeaways from coding the solution:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;To make an NxM list use:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;A = [0] * N
for i in range(N):
    A[i] = [0] * M
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I tried, &lt;code&gt;A = [[0] * M] * N&lt;/code&gt; initially, which is wrong. More info &lt;a href=&#34;https://docs.python.org/3/faq/programming.html#how-do-i-create-a-multidimensional-list&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;When saving the contents of a multidimensional list, use &lt;code&gt;copy.deepcopy(to_save)&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Testing is hard! More so when dealing with complicated outputs from a function. I will update this blog with tests soon.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Source code available &lt;a href=&#34;https://github.com/ploggingdev/n-queens&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Eight_queens_puzzle&#34;&gt;Eight queens problem on Wikipedia&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Backtracking&#34;&gt;Backtracking on Wikipedia&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Floating point arithmetic issues in Python 3</title>
      <link>https://www.ploggingdev.com/2016/11/floating-point-arithmetic-issues-in-python-3/</link>
      <pubDate>Sun, 27 Nov 2016 21:54:01 -0800</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2016/11/floating-point-arithmetic-issues-in-python-3/</guid>
      <description>&lt;p&gt;By default, numbers having a decimal point are represented as floating point numbers.&lt;/p&gt;

&lt;p&gt;Verification:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(type(1.5))
#output
&amp;lt;class &#39;float&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Floating point numbers are represented in computer hardware in base 2. Floating point numbers are used to represent decimal (base 10) numbers in the most common use cases. But most decimal fractions cannot be represented exactly as binary fractions.&lt;/p&gt;

&lt;p&gt;To understand this problem, consider the conversion of a decimal fraction to a decimal number: &lt;code&gt;1/3&lt;/code&gt; is equal to &lt;code&gt;0.333...&lt;/code&gt; with repeating 3&amp;rsquo;s. When represented as a decimal number, it will never be equal to &lt;code&gt;1/3&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Similarly, many decimal numbers cannot be represented accurately in base 2.&lt;/p&gt;

&lt;p&gt;Some examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(&amp;quot;0.1 + 0.2 = {}&amp;quot;.format(0.1+0.2))
#output
0.1 + 0.2 = 0.30000000000000004

print(&amp;quot;0.1 + 0.4 = {}&amp;quot;.format(0.1+0.4))
#output
0.1 + 0.4 = 0.5

print(&amp;quot;1/10 = {}&amp;quot;.format(1/10))
#output
1/10 = 0.1

print(&amp;quot;Is (0.1 + 0.1 + 0.1 == 0.3) ?&amp;quot;)
print(0.1 + 0.1 + 0.1 == 0.3)
#output
Is (0.1 + 0.1 + 0.1 == 0.3) ?
False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;In the above examples, notice that some decimal numbers can be represented accurately in base 2 while others cannot be represented accurately.&lt;/p&gt;

&lt;p&gt;I won&amp;rsquo;t pretend that I understand the intricate details behind why this happens, so I will link to some resources if you are interested to learn more: &lt;a href=&#34;http://www.lahey.com/float.htm&#34;&gt;The Perils of Floating Point&lt;/a&gt; and &lt;a href=&#34;http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&#34;&gt;What Every Computer Scientist Should Know About Floating-Point Arithmetic&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;How can we overcome this issue in Python? Some solutions are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;using &lt;code&gt;round()&lt;/code&gt; function&lt;/li&gt;
&lt;li&gt;using the &lt;code&gt;decimal&lt;/code&gt; module&lt;/li&gt;
&lt;li&gt;using the &lt;code&gt;fractions&lt;/code&gt; module&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let me explain each of these solutions a little more:&lt;/p&gt;

&lt;p&gt;Using &lt;code&gt;round()&lt;/code&gt;, floating point numbers can be rounded to a specified number of decimal places. If it&amp;rsquo;s used for post rounding a result (round after performing all operations on floats), working with floats will work as expected. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(&amp;quot;Is (0.1 + 0.1 + 0.1 == 0.3) ?&amp;quot;)
print(round(0.1 + 0.1 + 0.1, 5) == round(0.3, 5))
#output
Is (0.1 + 0.1 + 0.1 == 0.3) ?
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;round()&lt;/code&gt; function accepts a number as the first parameter and another number to specify the precision after the decimal point as the second parameter. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(round(10.33333, 3))
#output
10.333
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; It has been pointed out to me that using &lt;code&gt;round()&lt;/code&gt; may not be the best solution in certain cases where the rounded number will be used in calculations further in the program. Using &lt;code&gt;round()&lt;/code&gt; in such cases will lead to accuracy issues. An option is to use string formatting to display the required number of digits since this will not round the numbers. Syntax is as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(&#39;{: .3f}&#39;.format(10.34123))
#output
10.341
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another alternative is to use the &lt;code&gt;decimal&lt;/code&gt; module when dealing with decimal numbers and accuracy is very important. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from decimal import getcontext, Decimal
from math import pi

print(getcontext())

getcontext().prec = 5
print(Decimal(1)/Decimal(3))

getcontext().prec = 30
print(Decimal(pi))

#output
Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[], traps=
[InvalidOperation, DivisionByZero, Overflow])
0.33333
3.141592653589793115997963468544185161590576171875
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;getcontext()&lt;/code&gt; allows us to specify the precision and the rounding technique to be used, The default rounding technique is &lt;code&gt;ROUND_HALF_EVEN&lt;/code&gt; which rounds to nearest with ties going to nearest even integer.&lt;/p&gt;

&lt;p&gt;To deal directly with fractions, the &lt;code&gt;fractions&lt;/code&gt; module can be used which supports rational number arithmetic. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from fractions import Fraction

num1 = Fraction(2,3)
num2 = Fraction(1,3)

print(&amp;quot;num1 = {} and num2 = {}&amp;quot;.format(num1,num2))

print(num1 + num2)

print(num1 - num2)

print(num1*10)

print(num1/num2)

#output
num1 = 2/3 and num2 = 1/3
1
1/3
20/3
2
&amp;lt;class &#39;fractions.Fraction&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are multiple ways to construct fractions and the details can be found in the official documentation which is linked below.&lt;/p&gt;

&lt;p&gt;Source code for today&amp;rsquo;s plog is &lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/funny_floats.py&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/tutorial/floatingpoint.html&#34;&gt;Official tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/library/functions.html#round&#34;&gt;round() documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/library/decimal.html#module-decimal&#34;&gt;decimal module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/library/fractions.html#module-fractions&#34;&gt;fractions module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lahey.com/float.htm&#34;&gt;The Perils of Floating Point&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&#34;&gt;What Every Computer Scientist Should Know About Floating-Point Arithmetic&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Unit testing in Python 3</title>
      <link>https://www.ploggingdev.com/2016/11/unit-testing-in-python-3/</link>
      <pubDate>Sun, 27 Nov 2016 01:57:31 -0800</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2016/11/unit-testing-in-python-3/</guid>
      <description>&lt;p&gt;Unit testing is a method through which the smallest testable units of source code are tested to determine that they behave as expected. The important benefit of writing unit tests is that it enables us to check for any unwanted side effects when we alter the code and correct them.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;unittest&lt;/code&gt; framework is a built-in unit testing framework in Python.&lt;/p&gt;

&lt;p&gt;Some terminology:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;test fixture: the preparation needed to perform one or more tests, and any associate cleanup actions&lt;/li&gt;
&lt;li&gt;test case: individual unit of testing which checks for the correct response for a given input&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I will be covering a minimal subset of &lt;code&gt;unittest&lt;/code&gt; that will be enough to understand what unit testing is and how to go about writing test cases. To learn more, refer to the &lt;a href=&#34;https://docs.python.org/3/library/unittest.html&#34;&gt;official docs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A simple example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import unittest

class Test2(unittest.TestCase):
    
    def test_simple(self):
        self.assertEqual(2+2,4)

if __name__ == &#39;__main__&#39;:
    unittest.main()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Run the test using the following command&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python -m unittest -v test_2.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;test_simple (test_2.Test) ... ok

----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the module name is not provided, by default all unit tests in the current project are executed. The &lt;code&gt;-v&lt;/code&gt; argument is used to display verbose output.&lt;/p&gt;

&lt;p&gt;A few notes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;unittest&lt;/code&gt; module is imported&lt;/li&gt;
&lt;li&gt;Testcases are created by subclassing &lt;code&gt;unittest.TestCase&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The function that contains the tests begins with &lt;code&gt;test&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The TestCase class provides methods to check for and report failures.&lt;/p&gt;

&lt;p&gt;Some of the methods are listed below:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;assertEqual(a,b)&lt;/li&gt;
&lt;li&gt;assertNotEqual(a,b)&lt;/li&gt;
&lt;li&gt;assertTrue(x)&lt;/li&gt;
&lt;li&gt;assertFalse(x)&lt;/li&gt;
&lt;li&gt;assertIs(a,b)&lt;/li&gt;
&lt;li&gt;assertIn(a,b)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Another example of writing test cases:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import unittest

def division(x,y):
    &amp;quot;&amp;quot;&amp;quot;Return result of division&amp;quot;&amp;quot;&amp;quot;
    try:
        return x/y
    except ZeroDivisionError:
        print(&amp;quot;Division by zero&amp;quot;)

class Testexceptions(unittest.TestCase):

    def test_basic(self):
        self.assertEqual(division(10,5), 2.0)
        self.assertEqual(division(10,-2), -5.0)

    def test_type_exceptions(self):
        with self.assertRaises(TypeError):
            division(10,&#39;a&#39;)
    
    def test_zero_division(self):
        try:
            division(10,0)
        except ZeroDivisionError:
            self.fail(&amp;quot;ZeroDivisionError&amp;quot;)

if __name__ == &#39;__main__&#39;:
    unittest.main()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;test_basic (t.Testexceptions) ... ok
test_type_exceptions (t.Testexceptions) ... ok
test_zero_division (t.Testexceptions) ... Division by zero
ok

----------------------------------------------------------------------
Ran 3 tests in 0.000s

OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above example introduces &lt;code&gt;assertRaises&lt;/code&gt; which is used to verify that an exception is raised. There is no &lt;code&gt;assertNotRaises&lt;/code&gt;, so one way to achieve that is by using &lt;code&gt;try&lt;/code&gt; and &lt;code&gt;except&lt;/code&gt; as shown in the &lt;code&gt;test_zero_division&lt;/code&gt; method above.&lt;/p&gt;

&lt;p&gt;There are cases where there is a lot of repetitive code shared by tests, such as connecting to databases or fetching data from a URL. To factor out common code, there are a few methods that we can implement:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;setUp()&lt;/code&gt; is called before the execution of every test method&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tearDown()&lt;/code&gt; is called after the execution of every test method&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setUpClass()&lt;/code&gt; is called before tests in an individual class are run&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tearDownClass()&lt;/code&gt; is called after the tests in a class are run&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setUpModule()&lt;/code&gt; is called before code in a module is run&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tearDownModule()&lt;/code&gt; is called after all tests are run inside the module&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The following example demonstrates the order in which the methods are called.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tests.py&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import unittest

def setUpModule():
    print(&amp;quot;setUpModule() from tests.py&amp;quot;)

def tearDownModule():
    print(&amp;quot;tearDownModule() from tests.py&amp;quot;)

def division(x,y):
    &amp;quot;&amp;quot;&amp;quot;Return result of division&amp;quot;&amp;quot;&amp;quot;
    try:
        return x/y
    except ZeroDivisionError:
        print(&amp;quot;Division by zero&amp;quot;)

class Testexceptions(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        print(&amp;quot;setUpClass() from Testexceptions class in tests.py&amp;quot;)
    
    @classmethod
    def tearDownClass(cls):
        print(&amp;quot;tearDownClass() from Testexceptions class in tests.py&amp;quot;)

    def setUp(self):
        print(&amp;quot;setUp() from Testexceptions in tests.py&amp;quot;)
    def tearDown(self):
        print(&amp;quot;tearDown() from Testexceptions in tests.py&amp;quot;)
    
    def test_basic(self):
        self.assertEqual(division(10,5), 2.0)
        self.assertEqual(division(10,-2), -5.0)

    def test_type_exceptions(self):
        with self.assertRaises(TypeError):
            division(10,&#39;a&#39;)
    
    def test_zero_division(self):
        try:
            division(10,0)
        except ZeroDivisionError:
            self.fail(&amp;quot;ZeroDivisionError&amp;quot;)

if __name__ == &#39;__main__&#39;:
    unittest.main()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;test_2.py&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import unittest

def setUpModule():
    print(&amp;quot;setUpModule() from test_2.py&amp;quot;)

def tearDownModule():
    print(&amp;quot;tearDownModule() from test_2.py&amp;quot;)

class Test2(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        print(&amp;quot;setUpClass() from Test2 class in test_2.py&amp;quot;)

    
    def setUp(self):
        print(&amp;quot;setUp() from Test2 in test_2.py&amp;quot;)
    
    def test_simple(self):
        self.assertEqual(2+2,4)

    @unittest.skip(&amp;quot;Skipping a test demo&amp;quot;)
    def test_skip(self):
        self.fail(&amp;quot;Never happens&amp;quot;)

    def tearDown(self):
        print(&amp;quot;tearDown() from Test2 in test_2.py&amp;quot;)
    
    @classmethod
    def tearDownClass(cls):
        print(&amp;quot;tearDownClass() from Test2 class in test_2.py&amp;quot;)


if __name__ == &#39;__main__&#39;:
    unittest.main()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setUpModule() from test_2.py
setUpClass() from Test2 class in test_2.py
test_simple (test_2.Test2) ... setUp() from Test2 in test_2.py
tearDown() from Test2 in test_2.py
ok
test_skip (test_2.Test2) ... skipped &#39;Skipping a test demo&#39;
tearDownClass() from Test2 class in test_2.py
tearDownModule() from test_2.py
setUpModule() from tests.py
setUpClass() from Testexceptions class in tests.py
test_basic (tests.Testexceptions) ... setUp() from Testexceptions in tests.py
tearDown() from Testexceptions in tests.py
ok
test_type_exceptions (tests.Testexceptions) ... setUp() from Testexceptions in tests.py
tearDown() from Testexceptions in tests.py
ok
test_zero_division (tests.Testexceptions) ... setUp() from Testexceptions in tests.py
Division by zero
tearDown() from Testexceptions in tests.py
ok
tearDownClass() from Testexceptions class in tests.py
tearDownModule() from tests.py

----------------------------------------------------------------------
Ran 5 tests in 0.001s

OK (skipped=1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;unittest.skip(msg)&lt;/code&gt; decorator can be used to skip a test. This is useful when a test is known to fail and it needs to be fixed.&lt;/p&gt;

&lt;p&gt;Source code for today&amp;rsquo;s plog is &lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/tests.py&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/test_2.py&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Reference: &lt;a href=&#34;https://docs.python.org/3/library/unittest.html&#34;&gt;official docs&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Errors and exceptions in Python 3</title>
      <link>https://www.ploggingdev.com/2016/11/errors-and-exceptions-in-python-3/</link>
      <pubDate>Thu, 24 Nov 2016 23:42:14 -0800</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2016/11/errors-and-exceptions-in-python-3/</guid>
      <description>&lt;p&gt;There are two kinds of errors:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Syntax errors, where the program contains invalid syntax&lt;/li&gt;
&lt;li&gt;Exceptions, errors that occur during runtime, though the syntax is valid&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The list of built-in exceptions can be found &lt;a href=&#34;https://docs.python.org/3/library/exceptions.html#bltin-exceptions&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Syntax errors can be avoided by writing valid code and exceptions can be handled using &lt;code&gt;try&lt;/code&gt; and &lt;code&gt;except&lt;/code&gt;. An example of handling an exception:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def division(num1, num2):
    &amp;quot;&amp;quot;&amp;quot;Return num1/num2&amp;quot;&amp;quot;&amp;quot;
    return num1/num2

try:
    print(division(10,0))
except ZeroDivisionError:
    print(&amp;quot;You can&#39;t divide by zero&amp;quot;)
#output
You can&#39;t divide by zero
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;How &lt;code&gt;try&lt;/code&gt; and &lt;code&gt;except&lt;/code&gt; statements work:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The code inside the &lt;code&gt;try&lt;/code&gt; block is executed&lt;/li&gt;
&lt;li&gt;If no exception occurs, the &lt;code&gt;except&lt;/code&gt; block is skipped&lt;/li&gt;
&lt;li&gt;If an exception occurs, execution of remaining &lt;code&gt;try&lt;/code&gt; block is skipped and the &lt;code&gt;except&lt;/code&gt; block matching the raised exception is executed. If the exception has not been handled, it is passed to an outer &lt;code&gt;try&lt;/code&gt; block. If there is no outer &lt;code&gt;try&lt;/code&gt; block, it is an unhandled exception and execution stops.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the above example, note that I am not handling the exception inside the &lt;code&gt;division&lt;/code&gt; function. Instead I am handling the exception when the function is called.&lt;/p&gt;

&lt;p&gt;An &lt;code&gt;except&lt;/code&gt; clause can handle multiple exceptions using the following syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;except Exception1, Exception2 :
    #code to handle Exception1 and Exception2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An exception can be raised as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;raise ExceptionName(args)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The arguments are optional. If an exception class is present, it is instantiated by calling its constructor without arguments.&lt;/p&gt;

&lt;p&gt;A class in an except clause is compatible with an exception if it is the same class or a base class thereof. The following example demonstrates this concept:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Base(Exception):
    &amp;quot;&amp;quot;&amp;quot;Base class&amp;quot;&amp;quot;&amp;quot;
    pass

class Derived(Base):
    &amp;quot;&amp;quot;&amp;quot;Inherits from Base class&amp;quot;&amp;quot;&amp;quot;
    pass

for to_raise in [Base,Derived]:
    try:
        raise to_raise()
    except Derived:
        print(&amp;quot;Derived class&amp;quot;)
    except Base:
        print(&amp;quot;Base class&amp;quot;)

#output
Base class
Derived class

for to_raise in [Base,Derived]:
    try:
        raise to_raise()
    except Base:
        print(&amp;quot;Base class&amp;quot;)
    except Derived:
        print(&amp;quot;Derived class&amp;quot;)

#output
Base class
Base class
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is possible to catch wildcard exceptions as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try:
    raise Exception(&amp;quot;An exception occurred&amp;quot;)
except:
    print(&amp;quot;All exceptions are caught here&amp;quot;)
#output
All exceptions are caught here
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So every exception that is raised inside the &lt;code&gt;try&lt;/code&gt; block is caught by the wildcard &lt;code&gt;except&lt;/code&gt; by omitting the exception names. This should be avoided since it can hide any real programming errors.&lt;/p&gt;

&lt;p&gt;An optional &lt;code&gt;else&lt;/code&gt; clause is available, which executes the code inside when no exception is raised. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try:
    #some code
except ExceptionName:
    #handle exception
else:
    #executed when exception is not raised inside try
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When an exception is raised, it is possible to have data associated with the exception. This is useful for debugging purposes to understand under what circumstances the exception was raised. The arguments passed while raising an exception depend on the type of exception. The following is an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try:
    raise Exception(&#39;arg1&#39;, &#39;arg2&#39;)
except Exception as inst:
    print(type(inst))
    print(inst.args)
    print(inst)

    x,y = inst.args #unpacking arguments
    print(&amp;quot;x = {} y = {}&amp;quot;.format(x,y))
#output
&amp;lt;class &#39;Exception&#39;&amp;gt;
(&#39;arg1&#39;, &#39;arg2&#39;)
(&#39;arg1&#39;, &#39;arg2&#39;)
x = arg1 y = arg2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is possible to have user defined exceptions in Python by creating a new class. The new class has to be derived from The &lt;code&gt;Exception&lt;/code&gt; class either directly or indirectly. Though it is possible for exception classes to do anything a normal class can do, they are usually kept simple by only having a few attributes that contain information about the exception.&lt;/p&gt;

&lt;p&gt;If a module can raise different custom exceptions, it is a good practice to have a base class that inherits from &lt;code&gt;Exception&lt;/code&gt; and other classes that raise exceptions inherit from the base class. The following is a simple example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Error(Exception):
    &amp;quot;&amp;quot;&amp;quot;Base class for all exceptions in the module&amp;quot;&amp;quot;&amp;quot;
    name = &amp;quot;exceptions.py&amp;quot;

class FirstError(Error):
    &amp;quot;&amp;quot;&amp;quot;Specific exception class inherits from Error&amp;quot;&amp;quot;&amp;quot;
    
    def __init__(self,message):
        self.message = message

try:
    raise FirstError(&amp;quot;First custom exception&amp;quot;)
except FirstError as custom_exception:
    print(&amp;quot;FirstError has been raise with message: &amp;quot;,custom_exception.message, &amp;quot;\ncurrent module: &amp;quot;, custom_exception.name)

#output
FirstError has been raise with message:  First custom exception
current module:  exceptions.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s standard practice to have all exception classes end with Error.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;finally&lt;/code&gt; clause is available which can be used to define clean up actions. It is always executed, whether an exception occurred or not. The following is an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def proper_divide(x,y):
    &amp;quot;&amp;quot;&amp;quot;Returns x/y and handles exceptions&amp;quot;&amp;quot;&amp;quot;
    try:
        result = x/y
    except ZeroDivisionError:
        print(&amp;quot;Division by zero handled&amp;quot;)
    else:
        print(&amp;quot;Result is &amp;quot;, result)
    finally:
        print(&amp;quot;This is always executed&amp;quot;)

proper_divide(10,5)
#output
Result is  2.0
This is always executed
proper_divide(10,0)
#output
Division by zero handled
This is always executed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above example also shows how to use &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;except&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt; and &lt;code&gt;finally&lt;/code&gt; together.&lt;/p&gt;

&lt;p&gt;Code for today&amp;rsquo;s plog can be found &lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/exceptions.py&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/tutorial/errors.html&#34;&gt;Official tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/library/exceptions.html#bltin-exceptions&#34;&gt;Built-in exceptions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>File IO and JSON in Python 3</title>
      <link>https://www.ploggingdev.com/2016/11/file-io-and-json-in-python-3/</link>
      <pubDate>Tue, 22 Nov 2016 17:20:29 +0530</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2016/11/file-io-and-json-in-python-3/</guid>
      <description>&lt;p&gt;Before discussing file IO and json, let&amp;rsquo;s talk about accepting input from the user using &lt;code&gt;input()&lt;/code&gt;. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;name = input(&amp;quot;What&#39;s your name?\n&amp;quot;)
age = int(input(&amp;quot;Age?\n&amp;quot;))
print(&amp;quot;Name : {}  Age : {}&amp;quot;.format(name,age))
#output
What&#39;s your name?
plog
Age?
42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reading and writing files involves the following three steps:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Open the file using &lt;code&gt;open(filename, mode)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Read or write from or to the file using &lt;code&gt;read()&lt;/code&gt; or &lt;code&gt;write()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Close the file using &lt;code&gt;close()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;A file can be opened in the following modes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;r&lt;/code&gt; for read only. This is the default mode if mode is not specified&lt;/li&gt;
&lt;li&gt;&lt;code&gt;w&lt;/code&gt; for write only. This mode overwrites any existing content&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r+&lt;/code&gt; for read and write&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt; for appending content to a file&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def print_file(filename):
    &amp;quot;&amp;quot;&amp;quot;Prints the contents of a file&amp;quot;&amp;quot;&amp;quot;
    f = open(filename)
    print(f.read())
    f.close()

filename = &amp;quot;temp.txt&amp;quot;

#write to a file
temp_file = open(filename,&#39;w&#39;)
temp_file.write(&#39;First line.\nSecond line.\n&#39;)
temp_file.close()

print_file(filename)

#append to file
temp_file = open(&#39;temp.txt&#39;,&#39;a&#39;)
temp_file.write(&#39;Third line&#39;)
temp_file.close()

print_file(filename)
#output
First line.
Second line.

First line.
Second line.
Third line
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A context manager lets us open a file with the guarantee that the file will be closed even if an exception is raised. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;with open(&#39;workfile&#39;, &#39;r&#39;) as f:
    read_data = f.read()
print(f.closed)
#output
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some common exceptions to handle when dealing with files:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FileNotFoundError&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FileExistsError&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PermissionError&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;os&lt;/code&gt; module is used to interact with the operating system.&lt;/p&gt;

&lt;p&gt;The function, &lt;code&gt;os.path.join()&lt;/code&gt; is used to generate a string to represent a path. The generated path is dependent on the OS it is being run on. Eg- Windows uses backslash in paths while *nix OSes use a forward slash.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(os.path.join(&#39;home&#39;,&#39;plog&#39;,&#39;Desktop&#39;))
#output
home/plog/desktop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;os.getcwd()&lt;/code&gt; is used to retrieve the current working directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(os.getcwd())
/home/plog/Desktop/python_learn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;os.chdir(path)&lt;/code&gt; is used to change directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;os.chdir(&#39;modules&#39;)
print(os.getcwd())
/home/plog/Desktop/python_learn/modules
os.chdir(&#39;../&#39;)
print(os.getcwd())
/home/plog/Desktop/python_learn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To specify a path, relative or absolute paths can be used. &lt;code&gt;.&lt;/code&gt; specifies the current directory and &lt;code&gt;..&lt;/code&gt; specifies the parent directory.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;os.mkdir(name)&lt;/code&gt; is used to create a directory. &lt;code&gt;os.path.exists(path)&lt;/code&gt; is used to check if the path exists to avoid to decide whether to create the directory or not.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if not os.path.exists(&#39;./files_demo&#39;):
    os.mkdir(&#39;./files_demo&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;os.path.getsize(path)&lt;/code&gt; is used to find the size of the file in the specified path.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;os.listdir(path)&lt;/code&gt; lists all the folders and subfolders in the path specified.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;os.path.isdir(path)&lt;/code&gt; and &lt;code&gt;os.path.isfile(path)&lt;/code&gt; are used to verify if the specified paths are a directory and a file respectively. It returns &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(os.path.getsize(&#39;./temp.txt&#39;))
print(os.listdir(&#39;./&#39;))

print(os.path.isdir(&#39;./files_demo&#39;))
print(os.path.isfile(&#39;./temp.txt&#39;))
#output
35
[&#39;.git&#39;, &#39;requirements.txt&#39;, &#39;io.py&#39;, &#39;files_demo&#39;, &#39;strings.py&#39;, &#39;range.py&#39;, &#39;lists.py&#39;, &#39;LICENSE&#39;, &#39;datat
ypes.py&#39;, &#39;tuples.py&#39;, &#39;control_flow.py&#39;, &#39;hello.py&#39;, &#39;sets.py&#39;, &#39;dictionaries.py&#39;, &#39;functions.py&#39;, &#39;.gitig
nore&#39;, &#39;module_demo.py&#39;, &#39;classes.py&#39;, &#39;temp.txt&#39;, &#39;README.md&#39;, &#39;modules&#39;]
True
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;shelve&lt;/code&gt; module is used to save variables to a file and retrieve them. It stores the contents in binary format.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;shelf = shelve.open(&#39;shelve_test&#39;)
langs = [&#39;python&#39;, &#39;java&#39;, &#39;php&#39;]
shelf[&#39;langs&#39;] = langs
shelf.close()

shelf = shelve.open(&#39;shelve_test&#39;)
print(shelf[&#39;langs&#39;])
shelf.close()
#output
[&#39;python&#39;, &#39;java&#39;, &#39;php&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;shutil&lt;/code&gt; is a module that lets us move, copy, rename and delete files and folders.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#copy to directory
shutil.copy(&#39;./temp.txt&#39;,&#39;./files_demo&#39;)
#copy and entire folder recursively
shutil.copytree(&#39;./modules&#39;,&#39;./modules_backup&#39;)
#move a file
shutil.move(&#39;./temp.txt&#39;,&#39;./files_demo/temp_backup.txt&#39;)

if not os.path.exists(&#39;./files_demo_2&#39;):
    os.mkdir(&#39;./files_demo_2&#39;)

#move a folder
shutil.move(&#39;./files_demo_2&#39;,&#39;files_demo&#39;)
shutil.move(&#39;./shelve_test&#39;,&#39;./files_demo/files_demo_2&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Deletion of files and folders can be done using the &lt;code&gt;os&lt;/code&gt; and &lt;code&gt;shutil&lt;/code&gt; modules:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;os.unlink(path)&lt;/code&gt; deletes a file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.rmdir(path)&lt;/code&gt; deletes an empty folder&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shutil.rmtree(path)&lt;/code&gt; will delete a directory along with all files and subfolders&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since deletion of files and folders is a risky operation, the above functions can be replaced by the &lt;code&gt;send2trash&lt;/code&gt; module. The mentioned module moves the files and folders to be deleted into the trash so it gives us the chance to restore files and folders in case something unexpected happens.&lt;/p&gt;

&lt;p&gt;Install the &lt;code&gt;send2trash&lt;/code&gt; module using:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install send2trash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make sure to update the &lt;code&gt;requirements.txt&lt;/code&gt; using&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip freeze &amp;gt; requirements.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following example shows the usage of &lt;code&gt;send2trash&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;send2trash.send2trash(&#39;./files_demo&#39;)
send2trash.send2trash(&#39;./modules_backup&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A commonly used operation is to traverse a folder and all its files and subfolders recursively. This can be accomplished using &lt;code&gt;os.walk(path)&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for folderName, subfolders, filenames in os.walk(&#39;./&#39;):
    print(&#39;The current folder is &#39; + folderName)

    for subfolder in subfolders:
        print(&#39;SUBFOLDER OF &#39; + folderName + &#39;: &#39; + subfolder)
    for filename in filenames:
        print(&#39;FILE INSIDE &#39; + folderName + &#39;: &#39;+ filename)

    print(&#39;&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code prints all the folders, subfolders and files in the current directory. I did not paste the output, since it includes the contents of &lt;code&gt;.git&lt;/code&gt; which will unnecessarily clutter this plog.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;json&lt;/code&gt; module enables us to convert strings to json and vice-versa.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;json_string = &#39;{&amp;quot;first_name&amp;quot;: &amp;quot;Guido&amp;quot;, &amp;quot;last_name&amp;quot;:&amp;quot;Rossum&amp;quot;}&#39;
parsed_json = json.loads(json_string)
print(parsed_json[&#39;first_name&#39;])
print(json.dumps(parsed_json))
#output
Guido
{&amp;quot;last_name&amp;quot;: &amp;quot;Rossum&amp;quot;, &amp;quot;first_name&amp;quot;: &amp;quot;Guido&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;json.load()&lt;/code&gt; and &lt;code&gt;json.dump()&lt;/code&gt; also exist, which accept files instead of strings as arguments.&lt;/p&gt;

&lt;p&gt;The reason &lt;code&gt;shelve&lt;/code&gt; is preferred over serializing and deserializing objects as json is because of performance. Serializing and deserializing json is an expensive operation for custom objects. Json can be used for dictionaries and lists.&lt;/p&gt;

&lt;p&gt;Source code for today&amp;rsquo;s plog is &lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/io.py&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/tutorial/inputoutput.html&#34;&gt;Official docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://automatetheboringstuff.com/chapter8/&#34;&gt;Automate the boring stuff chapter 8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://automatetheboringstuff.com/chapter9/&#34;&gt;Automate the boring stuff chapter 9&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.python-guide.org/en/latest/scenarios/json/&#34;&gt;Hitchhiker&amp;rsquo;s guide to python&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>