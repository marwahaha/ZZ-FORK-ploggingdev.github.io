<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Plogging Dev</title>
    <link>https://www.ploggingdev.com/index.xml</link>
    <description>Recent content on Plogging Dev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>ploggingdev@gmail.com (Plogging Dev)</managingEditor>
    <webMaster>ploggingdev@gmail.com (Plogging Dev)</webMaster>
    <lastBuildDate>Sat, 03 Dec 2016 00:57:13 -0800</lastBuildDate>
    <atom:link href="https://www.ploggingdev.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Archive</title>
      <link>https://www.ploggingdev.com/archive/</link>
      <pubDate>Sat, 03 Dec 2016 00:57:13 -0800</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/archive/</guid>
      <description>

&lt;p&gt;This page contains links to all posts on this site.&lt;/p&gt;

&lt;h2 id=&#34;python&#34;&gt;Python&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ploggingdev.com/2016/11/beginning-python-3/&#34;&gt;Beginning Python 3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ploggingdev.com/2016/11/data-types-in-python-3/&#34;&gt;Data types in Python 3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ploggingdev.com/2016/11/strings-in-python-3/&#34;&gt;Strings in Python 3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ploggingdev.com/2016/11/lists-in-python-3/&#34;&gt;Lists in Python 3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ploggingdev.com/2016/11/tuples-in-python-3/&#34;&gt;Tuples in Python 3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ploggingdev.com/2016/11/ranges-in-python-3/&#34;&gt;Ranges in Python 3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ploggingdev.com/2016/11/sets-in-python-3/&#34;&gt;Sets in Python 3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ploggingdev.com/2016/11/dictionaries-in-python-3/&#34;&gt;Dictionaries in Python 3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ploggingdev.com/2016/11/control-flow-tools-in-python-3/&#34;&gt;Control flow tools in Python 3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ploggingdev.com/2016/11/functions-in-python-3/&#34;&gt;Functions in Python 3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ploggingdev.com/2016/11/modules-and-packages-in-python-3/&#34;&gt;Modules and packages in Python 3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ploggingdev.com/2016/11/classes-and-inheritance-in-python-3/&#34;&gt;Classes and inheritance in Python 3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ploggingdev.com/2016/11/virtual-environments-and-package-management-in-python-3/&#34;&gt;Virtual environments and package management in Python 3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ploggingdev.com/2016/11/file-io-and-json-in-python-3/&#34;&gt;File IO and JSON in Python 3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ploggingdev.com/2016/11/errors-and-exceptions-in-python-3/&#34;&gt;Errors and exceptions in Python 3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ploggingdev.com/2016/11/unit-testing-in-python-3/&#34;&gt;Unit testing in Python 3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ploggingdev.com/2016/11/floating-point-arithmetic-issues-in-python-3/&#34;&gt;Floating point arithmetic issues in Python 3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ploggingdev.com/2016/11/n-queens-solver-in-python-3/&#34;&gt;N queens solver in Python 3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ploggingdev.com/2016/12/list-comprehensions-iterators-generators-and-generator-expressions-in-python-3/&#34;&gt;List comprehensions, iterators, generators and generator expressions in Python 3&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;miscellaneous&#34;&gt;Miscellaneous&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ploggingdev.com/2016/11/hello-world/&#34;&gt;Hello World&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>List comprehensions, iterators, generators and generator expressions in Python 3</title>
      <link>https://www.ploggingdev.com/2016/12/list-comprehensions-iterators-generators-and-generator-expressions-in-python-3/</link>
      <pubDate>Fri, 02 Dec 2016 20:54:31 -0800</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2016/12/list-comprehensions-iterators-generators-and-generator-expressions-in-python-3/</guid>
      <description>&lt;p&gt;A list comprehension is a concise way to create lists that would normally require &lt;code&gt;for&lt;/code&gt; loops to build.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list1 = [x**2 for x in range(10)]
print(list1)
#output
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;List comprehension to create a list of tuples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list2 = [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
print(list2)
#output
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;List comprehension using an &lt;code&gt;if&lt;/code&gt; condition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list3 = [x for x in range(10) if x%2 != 0]
print(list3)
#output
[1, 3, 5, 7, 9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Only odd numbers are printed in the above example.&lt;/p&gt;

&lt;p&gt;Nested list comprehensions allow us to emulate nested &lt;code&gt;for&lt;/code&gt; loops in some way.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;matrix = [
    [1,2,3],
    [4,5,6],
    [7,8,9],
    [10,11,12]
]

transposed = [[row[i] for row in matrix] for i in range(3)]
print(transposed)
#output
[[1, 4, 7, 10], [2, 5, 8, 11], [3, 6, 9, 12]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The equivalent using nested &lt;code&gt;for&lt;/code&gt; loops would be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i in range(3):
    transposed.append([row[i] for row in matrix])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Moving on to iterators. Iterators let us iterate over container objects using &lt;code&gt;for&lt;/code&gt; loops. How to create an iterator: create a class which defines &lt;code&gt;__iter__()&lt;/code&gt; and &lt;code&gt;__next__()&lt;/code&gt;. &lt;code&gt;__iter__()&lt;/code&gt; returns an object with a &lt;code&gt;__next__()&lt;/code&gt; method. The &lt;code&gt;__next__()&lt;/code&gt; method which is used to retrieve the next object in the container. The &lt;code&gt;__next__()&lt;/code&gt; method will also need to raise a &lt;code&gt;StopIteration&lt;/code&gt; exception when there are no more elements to iterate over.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Squared:
    &amp;quot;&amp;quot;&amp;quot;Square all the numbers&amp;quot;&amp;quot;&amp;quot;

    def __init__(self, data):
        self.data = data
        self.index = 0
    
    def __iter__(self):
        return self

    def __next__(self):
        if self.index == len(self.data):
            raise StopIteration
        val = self.data[self.index] **2
        self.index += 1

        return val

values = Squared([1,2,3,10])

for i in values:
    print(i)

#output
1
4
9
100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generators are a way to create iterators. There is no need to explicitly define the &lt;code&gt;__iter__()&lt;/code&gt; and &lt;code&gt;__next__()&lt;/code&gt; methods, they are created automatically. Generators are functions that use the &lt;code&gt;yield&lt;/code&gt; statement to return data. When &lt;code&gt;__next__()&lt;/code&gt; is called, the function resumes where it left off and remembers the state of the program. The &lt;code&gt;StopIteration&lt;/code&gt; exception is also automatically raised.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def double_values(data):
    &amp;quot;&amp;quot;&amp;quot;Doubles all the values&amp;quot;&amp;quot;&amp;quot;
    for val in data:
        yield val*2

for i in double_values([4,5,3]):
    print(i)

#output
8
10
6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generator expressions are a simple but limited way to create generators and used in cases where the return value of the generator expression is used immediately. They have a syntax similar to list comprehensions, but use parantheses instead of brackets.&lt;/p&gt;

&lt;p&gt;Since generator expressions &lt;em&gt;generate&lt;/em&gt; the values on the fly instead of storing all the values in memory like list comprehensions do, they tend to be more memory efficient than the equivalent list comprehension but also tend to be a little slower. This is an important tradeoff to keep in mind.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exp = sum(i for i in range(5))
print(exp)

#output
10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Source code for today&amp;rsquo;s plog is &lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/generators.py&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.python.org/3/tutorial/datastructures.html#more-on-lists&#34;&gt;List comprehensions&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.python.org/3/tutorial/classes.html#iterators&#34;&gt;Generators, iterators and generator expressions&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>N queens solver in Python 3</title>
      <link>https://www.ploggingdev.com/2016/11/n-queens-solver-in-python-3/</link>
      <pubDate>Wed, 30 Nov 2016 04:14:07 -0800</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2016/11/n-queens-solver-in-python-3/</guid>
      <description>&lt;p&gt;What is the N queens problem?&lt;/p&gt;

&lt;p&gt;The N queens problem is the problem of placing N non-attacking queens on an NxN chessboard, for which solutions exist for all natural numbers N with the exception of N=2 and N=3.&lt;/p&gt;

&lt;p&gt;When N=1, the solution is trivial so the program will ask for a value of N such that &lt;code&gt;N &amp;gt;= 4&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I will solve this problem using backtracking. There are more efficient ways to solve this problem, but I will use backtracking since it&amp;rsquo;s the most intuitive way to arrive at the solution without getting into the mathematics of arriving at efficient solutions. Through solving these problems, I aim to better understand Python.&lt;/p&gt;

&lt;p&gt;What is backtracking?&lt;/p&gt;

&lt;p&gt;Backtracking is a general algorithm for finding all (or some) solutions to some computational problems, notably constraint satisfaction problems, that incrementally builds candidates to the solutions, and abandons each partial candidate &lt;em&gt;c&lt;/em&gt; (&amp;ldquo;backtracks&amp;rdquo;) as soon as it determines that &lt;em&gt;c&lt;/em&gt; cannot possibly be completed to a valid solution.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;A high level overview of how to use backtracking to solve the N queens problem:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;place a queen in the first column and first row&lt;/li&gt;
&lt;li&gt;place a queen in the second column such that it does not attack the queen in the first column&lt;/li&gt;
&lt;li&gt;continue placing non-attacking queens in the remaining columns&lt;/li&gt;
&lt;li&gt;if all N queens have been placed, a solution has been found. Remove the queen in the Nth column, and try incrementing the row of the queen in the (N-1)th column&lt;/li&gt;
&lt;li&gt;if it&amp;rsquo;s a dead end, remove the queen, increment the row of the queen in the previous column&lt;/li&gt;
&lt;li&gt;continue doing this until the queen in the 1st column exhausts all options and is in the row N&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The above explanation starts counting at 1, not 0 based counting.&lt;/p&gt;

&lt;p&gt;To see a visualization of backtracking, refer &lt;a href=&#34;https://en.wikipedia.org/wiki/Eight_queens_puzzle#Exercise_in_algorithm_design&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The solution:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import copy

def take_input():
    &amp;quot;&amp;quot;&amp;quot;Accepts the size of the chess board&amp;quot;&amp;quot;&amp;quot;

    while True:
        try:
            size = int(input(&#39;What is the size of the chessboard? n = \n&#39;))
            if size == 1:
                print(&amp;quot;Trivial solution, choose a board size of atleast 4&amp;quot;)
            if size &amp;lt;= 3:
                print(&amp;quot;Enter a value such that size&amp;gt;=4&amp;quot;)
                continue
            return size
        except ValueError:
            print(&amp;quot;Invalid value entered. Enter again&amp;quot;)

def get_board(size):
    &amp;quot;&amp;quot;&amp;quot;Returns an n by n board&amp;quot;&amp;quot;&amp;quot;
    board = [0]*size
    for ix in range(size):
        board[ix] = [0]*size
    return board

def print_solutions(solutions, size):
    &amp;quot;&amp;quot;&amp;quot;Prints all the solutions in user friendly way&amp;quot;&amp;quot;&amp;quot;
    for sol in solutions:
        for row in sol:
            print(row)
        print()
            
def is_safe(board, row, col, size):
    &amp;quot;&amp;quot;&amp;quot;Check if it&#39;s safe to place a queen at board[x][y]&amp;quot;&amp;quot;&amp;quot;

    #check row on left side
    for iy in range(col):
        if board[row][iy] == 1:
            return False
    
    ix, iy = row, col
    while ix &amp;gt;= 0 and iy &amp;gt;= 0:
        if board[ix][iy] == 1:
            return False
        ix-=1
        iy-=1
    
    jx, jy = row,col
    while jx &amp;lt; size and jy &amp;gt;= 0:
        if board[jx][jy] == 1:
            return False
        jx+=1
        jy-=1
    
    return True

def solve(board, col, size):
    &amp;quot;&amp;quot;&amp;quot;Use backtracking to find all solutions&amp;quot;&amp;quot;&amp;quot;
    #base case
    if col &amp;gt;= size:
        return
    
    for i in range(size):
        if is_safe(board, i, col, size):
            board[i][col] = 1
            if col == size-1:
                add_solution(board)
                board[i][col] = 0
                return
            solve(board, col+1, size)
            #backtrack
            board[i][col] = 0

def add_solution(board):
    &amp;quot;&amp;quot;&amp;quot;Saves the board state to the global variable &#39;solutions&#39;&amp;quot;&amp;quot;&amp;quot;
    global solutions
    saved_board = copy.deepcopy(board)
    solutions.append(saved_board)

size = take_input()

board = get_board(size)

solutions = []

solve(board, 0, size)

print_solutions(solutions, size)

print(&amp;quot;Total solutions = {}&amp;quot;.format(len(solutions)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output of the program when N=4:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;What is the size of the chessboard? n = 
4
[0, 0, 1, 0]
[1, 0, 0, 0]
[0, 0, 0, 1]
[0, 1, 0, 0]

[0, 1, 0, 0]
[0, 0, 0, 1]
[1, 0, 0, 0]
[0, 0, 1, 0]

Total solutions = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some important takeaways from coding the solution:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;To make an NxM list use:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;A = [0] * N
for i in range(N):
    A[i] = [0] * M
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I tried, &lt;code&gt;A = [[0] * M] * N&lt;/code&gt; initially, which is wrong. More info &lt;a href=&#34;https://docs.python.org/3/faq/programming.html#how-do-i-create-a-multidimensional-list&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;When saving the contents of a multidimensional list, use &lt;code&gt;copy.deepcopy(to_save)&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Testing is hard! More so when dealing with complicated outputs from a function. I will update this blog with tests soon.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Source code available &lt;a href=&#34;https://github.com/ploggingdev/n-queens&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Eight_queens_puzzle&#34;&gt;Eight queens problem on Wikipedia&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Backtracking&#34;&gt;Backtracking on Wikipedia&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Floating point arithmetic issues in Python 3</title>
      <link>https://www.ploggingdev.com/2016/11/floating-point-arithmetic-issues-in-python-3/</link>
      <pubDate>Sun, 27 Nov 2016 21:54:01 -0800</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2016/11/floating-point-arithmetic-issues-in-python-3/</guid>
      <description>&lt;p&gt;By default, numbers having a decimal point are represented as floating point numbers.&lt;/p&gt;

&lt;p&gt;Verification:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(type(1.5))
#output
&amp;lt;class &#39;float&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Floating point numbers are represented in computer hardware in base 2. Floating point numbers are used to represent decimal (base 10) numbers in the most common use cases. But most decimal fractions cannot be represented exactly as binary fractions.&lt;/p&gt;

&lt;p&gt;To understand this problem, consider the conversion of a decimal fraction to a decimal number: &lt;code&gt;1/3&lt;/code&gt; is equal to &lt;code&gt;0.333...&lt;/code&gt; with repeating 3&amp;rsquo;s. When represented as a decimal number, it will never be equal to &lt;code&gt;1/3&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Similarly, many decimal numbers cannot be represented accurately in base 2.&lt;/p&gt;

&lt;p&gt;Some examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(&amp;quot;0.1 + 0.2 = {}&amp;quot;.format(0.1+0.2))
#output
0.1 + 0.2 = 0.30000000000000004

print(&amp;quot;0.1 + 0.4 = {}&amp;quot;.format(0.1+0.4))
#output
0.1 + 0.4 = 0.5

print(&amp;quot;1/10 = {}&amp;quot;.format(1/10))
#output
1/10 = 0.1

print(&amp;quot;Is (0.1 + 0.1 + 0.1 == 0.3) ?&amp;quot;)
print(0.1 + 0.1 + 0.1 == 0.3)
#output
Is (0.1 + 0.1 + 0.1 == 0.3) ?
False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;In the above examples, notice that some decimal numbers can be represented accurately in base 2 while others cannot be represented accurately.&lt;/p&gt;

&lt;p&gt;I won&amp;rsquo;t pretend that I understand the intricate details behind why this happens, so I will link to some resources if you are interested to learn more: &lt;a href=&#34;http://www.lahey.com/float.htm&#34;&gt;The Perils of Floating Point&lt;/a&gt; and &lt;a href=&#34;http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&#34;&gt;What Every Computer Scientist Should Know About Floating-Point Arithmetic&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;How can we overcome this issue in Python? Some solutions are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;using &lt;code&gt;round()&lt;/code&gt; function&lt;/li&gt;
&lt;li&gt;using the &lt;code&gt;decimal&lt;/code&gt; module&lt;/li&gt;
&lt;li&gt;using the &lt;code&gt;fractions&lt;/code&gt; module&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let me explain each of these solutions a little more:&lt;/p&gt;

&lt;p&gt;Using &lt;code&gt;round()&lt;/code&gt;, floating point numbers can be rounded to a specified number of decimal places. If it&amp;rsquo;s used for post rounding a result (round after performing all operations on floats), working with floats will work as expected. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(&amp;quot;Is (0.1 + 0.1 + 0.1 == 0.3) ?&amp;quot;)
print(round(0.1 + 0.1 + 0.1, 5) == round(0.3, 5))
#output
Is (0.1 + 0.1 + 0.1 == 0.3) ?
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;round()&lt;/code&gt; function accepts a number as the first parameter and another number to specify the precision after the decimal point as the second parameter. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(round(10.33333, 3))
#output
10.333
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; It has been pointed out to me that using &lt;code&gt;round()&lt;/code&gt; may not be the best solution in certain cases where the rounded number will be used in calculations further in the program. Using &lt;code&gt;round()&lt;/code&gt; in such cases will lead to accuracy issues. An option is to use string formatting to display the required number of digits since this will not round the numbers. Syntax is as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(&#39;{: .3f}&#39;.format(10.34123))
#output
10.341
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another alternative is to use the &lt;code&gt;decimal&lt;/code&gt; module when dealing with decimal numbers and accuracy is very important. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from decimal import getcontext, Decimal
from math import pi

print(getcontext())

getcontext().prec = 5
print(Decimal(1)/Decimal(3))

getcontext().prec = 30
print(Decimal(pi))

#output
Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[], traps=
[InvalidOperation, DivisionByZero, Overflow])
0.33333
3.141592653589793115997963468544185161590576171875
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;getcontext()&lt;/code&gt; allows us to specify the precision and the rounding technique to be used, The default rounding technique is &lt;code&gt;ROUND_HALF_EVEN&lt;/code&gt; which rounds to nearest with ties going to nearest even integer.&lt;/p&gt;

&lt;p&gt;To deal directly with fractions, the &lt;code&gt;fractions&lt;/code&gt; module can be used which supports rational number arithmetic. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from fractions import Fraction

num1 = Fraction(2,3)
num2 = Fraction(1,3)

print(&amp;quot;num1 = {} and num2 = {}&amp;quot;.format(num1,num2))

print(num1 + num2)

print(num1 - num2)

print(num1*10)

print(num1/num2)

#output
num1 = 2/3 and num2 = 1/3
1
1/3
20/3
2
&amp;lt;class &#39;fractions.Fraction&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are multiple ways to construct fractions and the details can be found in the official documentation which is linked below.&lt;/p&gt;

&lt;p&gt;Source code for today&amp;rsquo;s plog is &lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/funny_floats.py&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/tutorial/floatingpoint.html&#34;&gt;Official tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/library/functions.html#round&#34;&gt;round() documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/library/decimal.html#module-decimal&#34;&gt;decimal module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/library/fractions.html#module-fractions&#34;&gt;fractions module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lahey.com/float.htm&#34;&gt;The Perils of Floating Point&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&#34;&gt;What Every Computer Scientist Should Know About Floating-Point Arithmetic&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Unit testing in Python 3</title>
      <link>https://www.ploggingdev.com/2016/11/unit-testing-in-python-3/</link>
      <pubDate>Sun, 27 Nov 2016 01:57:31 -0800</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2016/11/unit-testing-in-python-3/</guid>
      <description>&lt;p&gt;Unit testing is a method through which the smallest testable units of source code are tested to determine that they behave as expected. The important benefit of writing unit tests is that it enables us to check for any unwanted side effects when we alter the code and correct them.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;unittest&lt;/code&gt; framework is a built-in unit testing framework in Python.&lt;/p&gt;

&lt;p&gt;Some terminology:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;test fixture: the preparation needed to perform one or more tests, and any associate cleanup actions&lt;/li&gt;
&lt;li&gt;test case: individual unit of testing which checks for the correct response for a given input&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I will be covering a minimal subset of &lt;code&gt;unittest&lt;/code&gt; that will be enough to understand what unit testing is and how to go about writing test cases. To learn more, refer to the &lt;a href=&#34;https://docs.python.org/3/library/unittest.html&#34;&gt;official docs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A simple example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import unittest

class Test2(unittest.TestCase):
    
    def test_simple(self):
        self.assertEqual(2+2,4)

if __name__ == &#39;__main__&#39;:
    unittest.main()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Run the test using the following command&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python -m unittest -v test_2.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;test_simple (test_2.Test) ... ok

----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the module name is not provided, by default all unit tests in the current project are executed. The &lt;code&gt;-v&lt;/code&gt; argument is used to display verbose output.&lt;/p&gt;

&lt;p&gt;A few notes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;unittest&lt;/code&gt; module is imported&lt;/li&gt;
&lt;li&gt;Testcases are created by subclassing &lt;code&gt;unittest.TestCase&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The function that contains the tests begins with &lt;code&gt;test&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The TestCase class provides methods to check for and report failures.&lt;/p&gt;

&lt;p&gt;Some of the methods are listed below:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;assertEqual(a,b)&lt;/li&gt;
&lt;li&gt;assertNotEqual(a,b)&lt;/li&gt;
&lt;li&gt;assertTrue(x)&lt;/li&gt;
&lt;li&gt;assertFalse(x)&lt;/li&gt;
&lt;li&gt;assertIs(a,b)&lt;/li&gt;
&lt;li&gt;assertIn(a,b)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Another example of writing test cases:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import unittest

def division(x,y):
    &amp;quot;&amp;quot;&amp;quot;Return result of division&amp;quot;&amp;quot;&amp;quot;
    try:
        return x/y
    except ZeroDivisionError:
        print(&amp;quot;Division by zero&amp;quot;)

class Testexceptions(unittest.TestCase):

    def test_basic(self):
        self.assertEqual(division(10,5), 2.0)
        self.assertEqual(division(10,-2), -5.0)

    def test_type_exceptions(self):
        with self.assertRaises(TypeError):
            division(10,&#39;a&#39;)
    
    def test_zero_division(self):
        try:
            division(10,0)
        except ZeroDivisionError:
            self.fail(&amp;quot;ZeroDivisionError&amp;quot;)

if __name__ == &#39;__main__&#39;:
    unittest.main()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;test_basic (t.Testexceptions) ... ok
test_type_exceptions (t.Testexceptions) ... ok
test_zero_division (t.Testexceptions) ... Division by zero
ok

----------------------------------------------------------------------
Ran 3 tests in 0.000s

OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above example introduces &lt;code&gt;assertRaises&lt;/code&gt; which is used to verify that an exception is raised. There is no &lt;code&gt;assertNotRaises&lt;/code&gt;, so one way to achieve that is by using &lt;code&gt;try&lt;/code&gt; and &lt;code&gt;except&lt;/code&gt; as shown in the &lt;code&gt;test_zero_division&lt;/code&gt; method above.&lt;/p&gt;

&lt;p&gt;There are cases where there is a lot of repetitive code shared by tests, such as connecting to databases or fetching data from a URL. To factor out common code, there are a few methods that we can implement:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;setUp()&lt;/code&gt; is called before the execution of every test method&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tearDown()&lt;/code&gt; is called after the execution of every test method&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setUpClass()&lt;/code&gt; is called before tests in an individual class are run&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tearDownClass()&lt;/code&gt; is called after the tests in a class are run&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setUpModule()&lt;/code&gt; is called before code in a module is run&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tearDownModule()&lt;/code&gt; is called after all tests are run inside the module&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The following example demonstrates the order in which the methods are called.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tests.py&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import unittest

def setUpModule():
    print(&amp;quot;setUpModule() from tests.py&amp;quot;)

def tearDownModule():
    print(&amp;quot;tearDownModule() from tests.py&amp;quot;)

def division(x,y):
    &amp;quot;&amp;quot;&amp;quot;Return result of division&amp;quot;&amp;quot;&amp;quot;
    try:
        return x/y
    except ZeroDivisionError:
        print(&amp;quot;Division by zero&amp;quot;)

class Testexceptions(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        print(&amp;quot;setUpClass() from Testexceptions class in tests.py&amp;quot;)
    
    @classmethod
    def tearDownClass(cls):
        print(&amp;quot;tearDownClass() from Testexceptions class in tests.py&amp;quot;)

    def setUp(self):
        print(&amp;quot;setUp() from Testexceptions in tests.py&amp;quot;)
    def tearDown(self):
        print(&amp;quot;tearDown() from Testexceptions in tests.py&amp;quot;)
    
    def test_basic(self):
        self.assertEqual(division(10,5), 2.0)
        self.assertEqual(division(10,-2), -5.0)

    def test_type_exceptions(self):
        with self.assertRaises(TypeError):
            division(10,&#39;a&#39;)
    
    def test_zero_division(self):
        try:
            division(10,0)
        except ZeroDivisionError:
            self.fail(&amp;quot;ZeroDivisionError&amp;quot;)

if __name__ == &#39;__main__&#39;:
    unittest.main()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;test_2.py&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import unittest

def setUpModule():
    print(&amp;quot;setUpModule() from test_2.py&amp;quot;)

def tearDownModule():
    print(&amp;quot;tearDownModule() from test_2.py&amp;quot;)

class Test2(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        print(&amp;quot;setUpClass() from Test2 class in test_2.py&amp;quot;)

    
    def setUp(self):
        print(&amp;quot;setUp() from Test2 in test_2.py&amp;quot;)
    
    def test_simple(self):
        self.assertEqual(2+2,4)

    @unittest.skip(&amp;quot;Skipping a test demo&amp;quot;)
    def test_skip(self):
        self.fail(&amp;quot;Never happens&amp;quot;)

    def tearDown(self):
        print(&amp;quot;tearDown() from Test2 in test_2.py&amp;quot;)
    
    @classmethod
    def tearDownClass(cls):
        print(&amp;quot;tearDownClass() from Test2 class in test_2.py&amp;quot;)


if __name__ == &#39;__main__&#39;:
    unittest.main()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setUpModule() from test_2.py
setUpClass() from Test2 class in test_2.py
test_simple (test_2.Test2) ... setUp() from Test2 in test_2.py
tearDown() from Test2 in test_2.py
ok
test_skip (test_2.Test2) ... skipped &#39;Skipping a test demo&#39;
tearDownClass() from Test2 class in test_2.py
tearDownModule() from test_2.py
setUpModule() from tests.py
setUpClass() from Testexceptions class in tests.py
test_basic (tests.Testexceptions) ... setUp() from Testexceptions in tests.py
tearDown() from Testexceptions in tests.py
ok
test_type_exceptions (tests.Testexceptions) ... setUp() from Testexceptions in tests.py
tearDown() from Testexceptions in tests.py
ok
test_zero_division (tests.Testexceptions) ... setUp() from Testexceptions in tests.py
Division by zero
tearDown() from Testexceptions in tests.py
ok
tearDownClass() from Testexceptions class in tests.py
tearDownModule() from tests.py

----------------------------------------------------------------------
Ran 5 tests in 0.001s

OK (skipped=1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;unittest.skip(msg)&lt;/code&gt; decorator can be used to skip a test. This is useful when a test is known to fail and it needs to be fixed.&lt;/p&gt;

&lt;p&gt;Source code for today&amp;rsquo;s plog is &lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/tests.py&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/test_2.py&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Reference: &lt;a href=&#34;https://docs.python.org/3/library/unittest.html&#34;&gt;official docs&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Errors and exceptions in Python 3</title>
      <link>https://www.ploggingdev.com/2016/11/errors-and-exceptions-in-python-3/</link>
      <pubDate>Thu, 24 Nov 2016 23:42:14 -0800</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2016/11/errors-and-exceptions-in-python-3/</guid>
      <description>&lt;p&gt;There are two kinds of errors:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Syntax errors, where the program contains invalid syntax&lt;/li&gt;
&lt;li&gt;Exceptions, errors that occur during runtime, though the syntax is valid&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The list of built-in exceptions can be found &lt;a href=&#34;https://docs.python.org/3/library/exceptions.html#bltin-exceptions&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Syntax errors can be avoided by writing valid code and exceptions can be handled using &lt;code&gt;try&lt;/code&gt; and &lt;code&gt;except&lt;/code&gt;. An example of handling an exception:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def division(num1, num2):
    &amp;quot;&amp;quot;&amp;quot;Return num1/num2&amp;quot;&amp;quot;&amp;quot;
    return num1/num2

try:
    print(division(10,0))
except ZeroDivisionError:
    print(&amp;quot;You can&#39;t divide by zero&amp;quot;)
#output
You can&#39;t divide by zero
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;How &lt;code&gt;try&lt;/code&gt; and &lt;code&gt;except&lt;/code&gt; statements work:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The code inside the &lt;code&gt;try&lt;/code&gt; block is executed&lt;/li&gt;
&lt;li&gt;If no exception occurs, the &lt;code&gt;except&lt;/code&gt; block is skipped&lt;/li&gt;
&lt;li&gt;If an exception occurs, execution of remaining &lt;code&gt;try&lt;/code&gt; block is skipped and the &lt;code&gt;except&lt;/code&gt; block matching the raised exception is executed. If the exception has not been handled, it is passed to an outer &lt;code&gt;try&lt;/code&gt; block. If there is no outer &lt;code&gt;try&lt;/code&gt; block, it is an unhandled exception and execution stops.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the above example, note that I am not handling the exception inside the &lt;code&gt;division&lt;/code&gt; function. Instead I am handling the exception when the function is called.&lt;/p&gt;

&lt;p&gt;An &lt;code&gt;except&lt;/code&gt; clause can handle multiple exceptions using the following syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;except Exception1, Exception2 :
    #code to handle Exception1 and Exception2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An exception can be raised as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;raise ExceptionName(args)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The arguments are optional. If an exception class is present, it is instantiated by calling its constructor without arguments.&lt;/p&gt;

&lt;p&gt;A class in an except clause is compatible with an exception if it is the same class or a base class thereof. The following example demonstrates this concept:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Base(Exception):
    &amp;quot;&amp;quot;&amp;quot;Base class&amp;quot;&amp;quot;&amp;quot;
    pass

class Derived(Base):
    &amp;quot;&amp;quot;&amp;quot;Inherits from Base class&amp;quot;&amp;quot;&amp;quot;
    pass

for to_raise in [Base,Derived]:
    try:
        raise to_raise()
    except Derived:
        print(&amp;quot;Derived class&amp;quot;)
    except Base:
        print(&amp;quot;Base class&amp;quot;)

#output
Base class
Derived class

for to_raise in [Base,Derived]:
    try:
        raise to_raise()
    except Base:
        print(&amp;quot;Base class&amp;quot;)
    except Derived:
        print(&amp;quot;Derived class&amp;quot;)

#output
Base class
Base class
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is possible to catch wildcard exceptions as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try:
    raise Exception(&amp;quot;An exception occurred&amp;quot;)
except:
    print(&amp;quot;All exceptions are caught here&amp;quot;)
#output
All exceptions are caught here
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So every exception that is raised inside the &lt;code&gt;try&lt;/code&gt; block is caught by the wildcard &lt;code&gt;except&lt;/code&gt; by omitting the exception names. This should be avoided since it can hide any real programming errors.&lt;/p&gt;

&lt;p&gt;An optional &lt;code&gt;else&lt;/code&gt; clause is available, which executes the code inside when no exception is raised. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try:
    #some code
except ExceptionName:
    #handle exception
else:
    #executed when exception is not raised inside try
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When an exception is raised, it is possible to have data associated with the exception. This is useful for debugging purposes to understand under what circumstances the exception was raised. The arguments passed while raising an exception depend on the type of exception. The following is an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try:
    raise Exception(&#39;arg1&#39;, &#39;arg2&#39;)
except Exception as inst:
    print(type(inst))
    print(inst.args)
    print(inst)

    x,y = inst.args #unpacking arguments
    print(&amp;quot;x = {} y = {}&amp;quot;.format(x,y))
#output
&amp;lt;class &#39;Exception&#39;&amp;gt;
(&#39;arg1&#39;, &#39;arg2&#39;)
(&#39;arg1&#39;, &#39;arg2&#39;)
x = arg1 y = arg2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is possible to have user defined exceptions in Python by creating a new class. The new class has to be derived from The &lt;code&gt;Exception&lt;/code&gt; class either directly or indirectly. Though it is possible for exception classes to do anything a normal class can do, they are usually kept simple by only having a few attributes that contain information about the exception.&lt;/p&gt;

&lt;p&gt;If a module can raise different custom exceptions, it is a good practice to have a base class that inherits from &lt;code&gt;Exception&lt;/code&gt; and other classes that raise exceptions inherit from the base class. The following is a simple example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Error(Exception):
    &amp;quot;&amp;quot;&amp;quot;Base class for all exceptions in the module&amp;quot;&amp;quot;&amp;quot;
    name = &amp;quot;exceptions.py&amp;quot;

class FirstError(Error):
    &amp;quot;&amp;quot;&amp;quot;Specific exception class inherits from Error&amp;quot;&amp;quot;&amp;quot;
    
    def __init__(self,message):
        self.message = message

try:
    raise FirstError(&amp;quot;First custom exception&amp;quot;)
except FirstError as custom_exception:
    print(&amp;quot;FirstError has been raise with message: &amp;quot;,custom_exception.message, &amp;quot;\ncurrent module: &amp;quot;, custom_exception.name)

#output
FirstError has been raise with message:  First custom exception
current module:  exceptions.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s standard practice to have all exception classes end with Error.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;finally&lt;/code&gt; clause is available which can be used to define clean up actions. It is always executed, whether an exception occurred or not. The following is an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def proper_divide(x,y):
    &amp;quot;&amp;quot;&amp;quot;Returns x/y and handles exceptions&amp;quot;&amp;quot;&amp;quot;
    try:
        result = x/y
    except ZeroDivisionError:
        print(&amp;quot;Division by zero handled&amp;quot;)
    else:
        print(&amp;quot;Result is &amp;quot;, result)
    finally:
        print(&amp;quot;This is always executed&amp;quot;)

proper_divide(10,5)
#output
Result is  2.0
This is always executed
proper_divide(10,0)
#output
Division by zero handled
This is always executed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above example also shows how to use &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;except&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt; and &lt;code&gt;finally&lt;/code&gt; together.&lt;/p&gt;

&lt;p&gt;Code for today&amp;rsquo;s plog can be found &lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/exceptions.py&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/tutorial/errors.html&#34;&gt;Official tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/library/exceptions.html#bltin-exceptions&#34;&gt;Built-in exceptions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>File IO and JSON in Python 3</title>
      <link>https://www.ploggingdev.com/2016/11/file-io-and-json-in-python-3/</link>
      <pubDate>Tue, 22 Nov 2016 17:20:29 +0530</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2016/11/file-io-and-json-in-python-3/</guid>
      <description>&lt;p&gt;Before discussing file IO and json, let&amp;rsquo;s talk about accepting input from the user using &lt;code&gt;input()&lt;/code&gt;. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;name = input(&amp;quot;What&#39;s your name?\n&amp;quot;)
age = int(input(&amp;quot;Age?\n&amp;quot;))
print(&amp;quot;Name : {}  Age : {}&amp;quot;.format(name,age))
#output
What&#39;s your name?
plog
Age?
42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reading and writing files involves the following three steps:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Open the file using &lt;code&gt;open(filename, mode)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Read or write from or to the file using &lt;code&gt;read()&lt;/code&gt; or &lt;code&gt;write()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Close the file using &lt;code&gt;close()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;A file can be opened in the following modes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;r&lt;/code&gt; for read only. This is the default mode if mode is not specified&lt;/li&gt;
&lt;li&gt;&lt;code&gt;w&lt;/code&gt; for write only. This mode overwrites any existing content&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r+&lt;/code&gt; for read and write&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt; for appending content to a file&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def print_file(filename):
    &amp;quot;&amp;quot;&amp;quot;Prints the contents of a file&amp;quot;&amp;quot;&amp;quot;
    f = open(filename)
    print(f.read())
    f.close()

filename = &amp;quot;temp.txt&amp;quot;

#write to a file
temp_file = open(filename,&#39;w&#39;)
temp_file.write(&#39;First line.\nSecond line.\n&#39;)
temp_file.close()

print_file(filename)

#append to file
temp_file = open(&#39;temp.txt&#39;,&#39;a&#39;)
temp_file.write(&#39;Third line&#39;)
temp_file.close()

print_file(filename)
#output
First line.
Second line.

First line.
Second line.
Third line
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A context manager lets us open a file with the guarantee that the file will be closed even if an exception is raised. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;with open(&#39;workfile&#39;, &#39;r&#39;) as f:
    read_data = f.read()
print(f.closed)
#output
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some common exceptions to handle when dealing with files:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FileNotFoundError&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FileExistsError&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PermissionError&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;os&lt;/code&gt; module is used to interact with the operating system.&lt;/p&gt;

&lt;p&gt;The function, &lt;code&gt;os.path.join()&lt;/code&gt; is used to generate a string to represent a path. The generated path is dependent on the OS it is being run on. Eg- Windows uses backslash in paths while *nix OSes use a forward slash.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(os.path.join(&#39;home&#39;,&#39;plog&#39;,&#39;Desktop&#39;))
#output
home/plog/desktop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;os.getcwd()&lt;/code&gt; is used to retrieve the current working directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(os.getcwd())
/home/plog/Desktop/python_learn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;os.chdir(path)&lt;/code&gt; is used to change directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;os.chdir(&#39;modules&#39;)
print(os.getcwd())
/home/plog/Desktop/python_learn/modules
os.chdir(&#39;../&#39;)
print(os.getcwd())
/home/plog/Desktop/python_learn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To specify a path, relative or absolute paths can be used. &lt;code&gt;.&lt;/code&gt; specifies the current directory and &lt;code&gt;..&lt;/code&gt; specifies the parent directory.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;os.mkdir(name)&lt;/code&gt; is used to create a directory. &lt;code&gt;os.path.exists(path)&lt;/code&gt; is used to check if the path exists to avoid to decide whether to create the directory or not.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if not os.path.exists(&#39;./files_demo&#39;):
    os.mkdir(&#39;./files_demo&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;os.path.getsize(path)&lt;/code&gt; is used to find the size of the file in the specified path.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;os.listdir(path)&lt;/code&gt; lists all the folders and subfolders in the path specified.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;os.path.isdir(path)&lt;/code&gt; and &lt;code&gt;os.path.isfile(path)&lt;/code&gt; are used to verify if the specified paths are a directory and a file respectively. It returns &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(os.path.getsize(&#39;./temp.txt&#39;))
print(os.listdir(&#39;./&#39;))

print(os.path.isdir(&#39;./files_demo&#39;))
print(os.path.isfile(&#39;./temp.txt&#39;))
#output
35
[&#39;.git&#39;, &#39;requirements.txt&#39;, &#39;io.py&#39;, &#39;files_demo&#39;, &#39;strings.py&#39;, &#39;range.py&#39;, &#39;lists.py&#39;, &#39;LICENSE&#39;, &#39;datat
ypes.py&#39;, &#39;tuples.py&#39;, &#39;control_flow.py&#39;, &#39;hello.py&#39;, &#39;sets.py&#39;, &#39;dictionaries.py&#39;, &#39;functions.py&#39;, &#39;.gitig
nore&#39;, &#39;module_demo.py&#39;, &#39;classes.py&#39;, &#39;temp.txt&#39;, &#39;README.md&#39;, &#39;modules&#39;]
True
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;shelve&lt;/code&gt; module is used to save variables to a file and retrieve them. It stores the contents in binary format.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;shelf = shelve.open(&#39;shelve_test&#39;)
langs = [&#39;python&#39;, &#39;java&#39;, &#39;php&#39;]
shelf[&#39;langs&#39;] = langs
shelf.close()

shelf = shelve.open(&#39;shelve_test&#39;)
print(shelf[&#39;langs&#39;])
shelf.close()
#output
[&#39;python&#39;, &#39;java&#39;, &#39;php&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;shutil&lt;/code&gt; is a module that lets us move, copy, rename and delete files and folders.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#copy to directory
shutil.copy(&#39;./temp.txt&#39;,&#39;./files_demo&#39;)
#copy and entire folder recursively
shutil.copytree(&#39;./modules&#39;,&#39;./modules_backup&#39;)
#move a file
shutil.move(&#39;./temp.txt&#39;,&#39;./files_demo/temp_backup.txt&#39;)

if not os.path.exists(&#39;./files_demo_2&#39;):
    os.mkdir(&#39;./files_demo_2&#39;)

#move a folder
shutil.move(&#39;./files_demo_2&#39;,&#39;files_demo&#39;)
shutil.move(&#39;./shelve_test&#39;,&#39;./files_demo/files_demo_2&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Deletion of files and folders can be done using the &lt;code&gt;os&lt;/code&gt; and &lt;code&gt;shutil&lt;/code&gt; modules:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;os.unlink(path)&lt;/code&gt; deletes a file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.rmdir(path)&lt;/code&gt; deletes an empty folder&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shutil.rmtree(path)&lt;/code&gt; will delete a directory along with all files and subfolders&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since deletion of files and folders is a risky operation, the above functions can be replaced by the &lt;code&gt;send2trash&lt;/code&gt; module. The mentioned module moves the files and folders to be deleted into the trash so it gives us the chance to restore files and folders in case something unexpected happens.&lt;/p&gt;

&lt;p&gt;Install the &lt;code&gt;send2trash&lt;/code&gt; module using:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install send2trash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make sure to update the &lt;code&gt;requirements.txt&lt;/code&gt; using&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip freeze &amp;gt; requirements.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following example shows the usage of &lt;code&gt;send2trash&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;send2trash.send2trash(&#39;./files_demo&#39;)
send2trash.send2trash(&#39;./modules_backup&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A commonly used operation is to traverse a folder and all its files and subfolders recursively. This can be accomplished using &lt;code&gt;os.walk(path)&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for folderName, subfolders, filenames in os.walk(&#39;./&#39;):
    print(&#39;The current folder is &#39; + folderName)

    for subfolder in subfolders:
        print(&#39;SUBFOLDER OF &#39; + folderName + &#39;: &#39; + subfolder)
    for filename in filenames:
        print(&#39;FILE INSIDE &#39; + folderName + &#39;: &#39;+ filename)

    print(&#39;&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code prints all the folders, subfolders and files in the current directory. I did not paste the output, since it includes the contents of &lt;code&gt;.git&lt;/code&gt; which will unnecessarily clutter this plog.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;json&lt;/code&gt; module enables us to convert strings to json and vice-versa.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;json_string = &#39;{&amp;quot;first_name&amp;quot;: &amp;quot;Guido&amp;quot;, &amp;quot;last_name&amp;quot;:&amp;quot;Rossum&amp;quot;}&#39;
parsed_json = json.loads(json_string)
print(parsed_json[&#39;first_name&#39;])
print(json.dumps(parsed_json))
#output
Guido
{&amp;quot;last_name&amp;quot;: &amp;quot;Rossum&amp;quot;, &amp;quot;first_name&amp;quot;: &amp;quot;Guido&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;json.load()&lt;/code&gt; and &lt;code&gt;json.dump()&lt;/code&gt; also exist, which accept files instead of strings as arguments.&lt;/p&gt;

&lt;p&gt;The reason &lt;code&gt;shelve&lt;/code&gt; is preferred over serializing and deserializing objects as json is because of performance. Serializing and deserializing json is an expensive operation for custom objects. Json can be used for dictionaries and lists.&lt;/p&gt;

&lt;p&gt;Source code for today&amp;rsquo;s plog is &lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/io.py&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/tutorial/inputoutput.html&#34;&gt;Official docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://automatetheboringstuff.com/chapter8/&#34;&gt;Automate the boring stuff chapter 8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://automatetheboringstuff.com/chapter9/&#34;&gt;Automate the boring stuff chapter 9&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.python-guide.org/en/latest/scenarios/json/&#34;&gt;Hitchhiker&amp;rsquo;s guide to python&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Virtual environments and package management in Python 3</title>
      <link>https://www.ploggingdev.com/2016/11/virtual-environments-and-package-management-in-python-3/</link>
      <pubDate>Mon, 21 Nov 2016 21:46:23 +0530</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2016/11/virtual-environments-and-package-management-in-python-3/</guid>
      <description>&lt;p&gt;A virtual environment is a directory containing a Python installation and any additional packages. Since a virtual environment is isolated, any changes made will not affect the global installation of Python. It also enables the usage of different versions of the same package in multiple virtual environments.&lt;/p&gt;

&lt;p&gt;To create a virtual environment, the &lt;code&gt;venv&lt;/code&gt; module will be used. The &lt;code&gt;virtualenv&lt;/code&gt; module also can be used, but &lt;code&gt;venv&lt;/code&gt; is the officially recommended solution so that&amp;rsquo;s what I will be using. The current Python 3 documentation recommends the usage of &lt;code&gt;pyvenv&lt;/code&gt;, which is a wrapper around &lt;code&gt;venv&lt;/code&gt;. Since &lt;code&gt;pyvenv&lt;/code&gt; will be deprecated soon, avoid using &lt;code&gt;pyvenv&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Installation of &lt;code&gt;venv&lt;/code&gt; on Ubuntu 16.04:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt install python3-venv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To create a new virtual environment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python3 -m venv python_learn_venv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;To activate the newly created virtual environment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source python_learn_venv/bin/activate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The terminal will reflect that a virtual environment has been activated by displaying it&amp;rsquo;s name.&lt;/p&gt;

&lt;p&gt;To deactivate a virtual environment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deactivate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After activating a virtual environment, packages can be managed using a tool called &lt;code&gt;pip&lt;/code&gt;. The tool lets you install, upgrade, remove and search for packages.&lt;/p&gt;

&lt;p&gt;To search for a package:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip search package_name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To install a package:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install package_name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To uninstall a package:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip uninstall package_name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To upgrade a package to the latest version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install --upgrade package_name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To view information about a particular package:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip show package_name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To view the list of packages installed in the current virtual environment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip freeze
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;pip list&lt;/code&gt; can be used, but &lt;code&gt;pip freeze&lt;/code&gt; is preferred, since the output is in the format that &lt;code&gt;pip install&lt;/code&gt; expects.&lt;/p&gt;

&lt;p&gt;To keep track of the packages installed in your virtual environment, save the contents of &lt;code&gt;pip freeze&lt;/code&gt; to a file called &lt;code&gt;requirements.txt&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip freeze &amp;gt; requirements.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;requirements.txt&lt;/code&gt; can be commited to version control.&lt;/p&gt;

&lt;p&gt;To install packages from requirements.txt`:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A note about &lt;code&gt;pip&lt;/code&gt; and &lt;code&gt;pip3&lt;/code&gt;: when a virtual environment has been created with Python 3 and is active, &lt;code&gt;pip&lt;/code&gt; refers to &lt;code&gt;pip3&lt;/code&gt;. When a virtual environment is not activated, &lt;code&gt;pip&lt;/code&gt; will refer to &lt;code&gt;pip2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;An example of &lt;code&gt;requirements.txt&lt;/code&gt; is &lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/requirements.txt&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/tutorial/venv.html&#34;&gt;Official docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://superuser.com/questions/1039369/how-to-create-a-python3-virtual-environment-as-of-2016&#34;&gt;Superuser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/learnpython/comments/4hsudz/pyvenv_vs_virtualenv/&#34;&gt;Reddit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Classes and inheritance in Python 3</title>
      <link>https://www.ploggingdev.com/2016/11/classes-and-inheritance-in-python-3/</link>
      <pubDate>Sat, 19 Nov 2016 07:38:24 +0530</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2016/11/classes-and-inheritance-in-python-3/</guid>
      <description>&lt;p&gt;From Wikipedia: In object-oriented programming, a class is an extensible program-code-template for creating objects, providing initial values for state (member variables) and implementations of behavior (member functions or methods).&lt;/p&gt;

&lt;p&gt;Features of classes in Python:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Multiple inheritance permitted&lt;/li&gt;
&lt;li&gt;Derived class can override base class methods&lt;/li&gt;
&lt;li&gt;Base class methods can be called using &lt;code&gt;super().method_name()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Class members are dynamic, can be modified at runtime&lt;/li&gt;
&lt;li&gt;Class members are public, methods are virtual (can be overridden)&lt;/li&gt;
&lt;li&gt;The first parameter in a method is a reference to the calling object, usually &lt;code&gt;self&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Operator overloading is supported&lt;/li&gt;
&lt;li&gt;Aliasing of objects is supported&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Classes are defined as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class ClassName:
    &amp;quot;&amp;quot;&amp;quot;Docstring&amp;quot;&amp;quot;&amp;quot;
    statement_1
    .
    .
    .
    statement_n

#create an instance of the class
var = ClassName()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Class variables are common to all instances and are often used to represent immutable data. An example is the &lt;code&gt;details&lt;/code&gt; variable in the below example.&lt;/p&gt;

&lt;p&gt;An instance variable is unique to every instance of the class ie object. Examples are &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; variables in the following class.&lt;/p&gt;

&lt;p&gt;To initialize an object, the &lt;code&gt;__init__(self)&lt;/code&gt; method is used. It&amp;rsquo;s like a constructor, thinking in terms of Java.&lt;/p&gt;

&lt;p&gt;To specify how the contents of an object should be printed, the &lt;code&gt;__str__(self)&lt;/code&gt; method is used. When an object is printed using &lt;code&gt;print(object_variable)&lt;/code&gt;, the &lt;code&gt;__str__(self)&lt;/code&gt; method is called.&lt;/p&gt;

&lt;p&gt;To format strings the &lt;code&gt;string.format()&lt;/code&gt; will be used. The &lt;a href=&#34;https://docs.python.org/3/library/string.html#formatstrings&#34;&gt;official docs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Difference between a function and a method: a function is a named grouping of statements while a method is a function that is associated with a specific class.&lt;/p&gt;

&lt;p&gt;To define a method, it has to be defined inside a class and is called using &lt;code&gt;object.method()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Functions are of two types: pure and modifiers. Pure functions don&amp;rsquo;t modify the data it receives and is the model followed in functional programming. Modifier functions, as the name suggests, modify the data it receives. The cool thing about Python is that it allows different programming paradigms such as functional programming and object oriented programming, and you are free to use whichever programming paradigm suits you.&lt;/p&gt;

&lt;p&gt;Operator overloading is possible in Python by overriding certain methods. Eg- override &lt;code&gt;__add__()&lt;/code&gt; to allow using the &lt;code&gt;+&lt;/code&gt; operator on instances of the class. To learn more refer &lt;a href=&#34;https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Objects can be copied using &lt;code&gt;copy.copy()&lt;/code&gt;. A new object is created with the same contents as the original object.&lt;/p&gt;

&lt;p&gt;All these concepts are demonstrated in the following example.&lt;/p&gt;

&lt;p&gt;Point class example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import copy

class Point:
    &amp;quot;&amp;quot;&amp;quot;A class to represent a point&amp;quot;&amp;quot;&amp;quot;

    details = &amp;quot;Represent points&amp;quot;

    def __init__(self,x=0,y=0):
        self.x=x
        self.y=y
    
    def __str__(self):
        return &amp;quot;x={} y={}&amp;quot;.format(self.x,self.y)

    def get_sum(self):
        &amp;quot;&amp;quot;&amp;quot;Return sum of x and y components&amp;quot;&amp;quot;&amp;quot;
        return self.x + self.y
    
    def add_point(self,to_add):
        &amp;quot;&amp;quot;&amp;quot;Update self by add x and y component of new_point&amp;quot;&amp;quot;&amp;quot;
        self.x += to_add.x
        self.y += to_add.y

    def __add__(self,new_point):
        self.x += new_point.x
        self.y += new_point.y
        return self

def print_point(point):
    &amp;quot;&amp;quot;&amp;quot;print contents of given point&amp;quot;&amp;quot;&amp;quot;
    print(&amp;quot;x={} y={}&amp;quot;.format(point.x,point.y))

point = Point(10,20)
print(point)

print(point.details)
print(point.get_sum())

new_point = Point(2,4)
print(new_point)

point.add_point(new_point)
print(point)

print_point(new_point)

copied_point = copy.copy(point)
copied_point.x = 5
copied_point.y = 5
print(point)
print(copied_point)

print(copied_point + new_point)
#output
x=10 y=20
Represent points
30
x=2 y=4
x=12 y=24
x=2 y=4
x=12 y=24
x=5 y=5
x=7 y=9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A note about namespaces and scopes: a namespace is a mapping of names to objects. Eg- global namespace, module namespace, function namespace. A scope is a textual region where the namespace is accessible.&lt;/p&gt;

&lt;p&gt;During execution, there are at least three nested scopes whose namespaces are directly accessible:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Innermost scope, an &lt;code&gt;if&lt;/code&gt; block or a loop&lt;/li&gt;
&lt;li&gt;Enclosing function scope&lt;/li&gt;
&lt;li&gt;Module scope&lt;/li&gt;
&lt;li&gt;Global scope&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Variables can be declared as &lt;code&gt;nonlocal&lt;/code&gt; or &lt;code&gt;global&lt;/code&gt;. If they are not specified, he defualt is the current scope (need to check). A &lt;code&gt;nonlocal&lt;/code&gt; statement is used to indicate a variable has to be rebound in the enclosing scope. A &lt;code&gt;global&lt;/code&gt; statement indicates that a variable has to be rebound in the global scope. Note that this is applicable only for rebinding variables, not for modifying mutable data types. To learn more refer &lt;a href=&#34;https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Inheritance is supported. Syntax is as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class BaseClass:
    &amp;quot;&amp;quot;&amp;quot;Docstring&amp;quot;&amp;quot;&amp;quot;
    statement_1
    .
    .
    .
    statement_n

class DerivedClass(BaseClass):
    &amp;quot;&amp;quot;&amp;quot;Docstring&amp;quot;&amp;quot;&amp;quot;
    statement_1
    .
    .
    .
    statement_n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Multiple inheritance is supprted using &lt;code&gt;class Derived(Base1,Base2):&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It should be noted that multiple inheritance can introduce a situation where multiple base classes inherit from the same base class. To learn more about how method resolution works refer &lt;a href=&#34;https://docs.python.org/3/tutorial/classes.html#multiple-inheritance&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A simple example of inheritance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Vehicle(object):
    &amp;quot;&amp;quot;&amp;quot;Represents a vehicle&amp;quot;&amp;quot;&amp;quot;

    def __init__(self,engine_power=100):
        self.engine_power = engine_power
    
    def __str__(self):
        return &amp;quot;Engine power : {}HP&amp;quot;.format(self.engine_power)
    
    def print_name(self):
        print(&amp;quot;From vehicle&amp;quot;)
    
class Car(Vehicle):
    &amp;quot;&amp;quot;&amp;quot;Represents a car&amp;quot;&amp;quot;&amp;quot;

    def __init__(self,wheels=4):
        super().__init__()
        self.wheels = wheels
    
    def __str__(self):
        return &amp;quot;Engine power : {}HP , Wheels = {}&amp;quot;.format(self.engine_power,self.wheels)
    
    def print_name(self):
        print(&amp;quot;From vehicle&amp;quot;)

car = Car()
print(car)
car.print_name()
#output
Engine power : 100HP , Wheels = 4
From vehicle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Source code for today&amp;rsquo;s plog is &lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/classes.py&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/tutorial/classes.html&#34;&gt;Official tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types&#34;&gt;Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Class_(computer_programming)&#34;&gt;Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/library/string.html#formatstrings&#34;&gt;String formatting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Modules and packages in Python 3</title>
      <link>https://www.ploggingdev.com/2016/11/modules-and-packages-in-python-3/</link>
      <pubDate>Wed, 16 Nov 2016 14:13:24 +0530</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2016/11/modules-and-packages-in-python-3/</guid>
      <description>&lt;p&gt;A module is a file that contains Python definitions and statements with a &lt;code&gt;.py&lt;/code&gt; extension. So technically,
all the code that I posted so far has been in the form of modules. Modules are a way to organize code
in Python so that closely related functions and definitions are grouped together into a module.
It makes code reusable.&lt;/p&gt;

&lt;p&gt;A related concept is packages. Packages are just a way to organize modules into a namespace. A package
can be thought of as a directory that contains modules and subpackages. For Python to treat a directory as
a package, a file named &lt;code&gt;__init__.py&lt;/code&gt; is required in the directory. The &lt;code&gt;__init__.py&lt;/code&gt; can also contain
code that will be executed when the package is first imported, typically initialization code.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;The following example clarifies these concepts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A file named &lt;code&gt;module_demo.py&lt;/code&gt; is created.&lt;/li&gt;
&lt;li&gt;A directory named &lt;code&gt;modules&lt;/code&gt; is created.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;modules&lt;/code&gt; directory contains an empty &lt;code&gt;__init__.py&lt;/code&gt; to signify that it is a package.&lt;/li&gt;
&lt;li&gt;In the &lt;code&gt;modules&lt;/code&gt; package, a &lt;code&gt;useless_print.py&lt;/code&gt; file is created, which is a module.&lt;/li&gt;
&lt;li&gt;To demonstrate submodules, a &lt;code&gt;submodule&lt;/code&gt; directory is created inside &lt;code&gt;modules&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Inside &lt;code&gt;submodule&lt;/code&gt;, an &lt;code&gt;__init__.py&lt;/code&gt; file is created to signify that it is a package.&lt;/li&gt;
&lt;li&gt;Inside &lt;code&gt;submodule&lt;/code&gt;, a module named &lt;code&gt;another_print.py&lt;/code&gt; is created.&lt;/li&gt;
&lt;li&gt;The functions &lt;code&gt;useless_print&lt;/code&gt; and &lt;code&gt;another_print&lt;/code&gt; from the modules by the same name are imported
into &lt;code&gt;module_demo.py&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The imported functions are invoked from &lt;code&gt;module_demo.py&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;text
some more text
some more text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By adding&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if __name__ == &amp;quot;__main__&amp;quot;:
    import sys
    #pass sys.argv to relevant function
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;a module can be used as a script and a module. Executing the module with &lt;code&gt;python module.py arguments&lt;/code&gt; , the code in the module will be executed, just as if you imported it, but with the &lt;code&gt;__name__&lt;/code&gt; set to &lt;code&gt;__main__&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The source code can be found in the &lt;a href=&#34;https://github.com/ploggingdev/python_learn&#34;&gt;repository&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A few notes about modules and packages in Python:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Be explicit: import only what is required.&lt;/li&gt;
&lt;li&gt;Avoid &lt;code&gt;from modules import *&lt;/code&gt;. It clutters the namespace and can result in namespace clashes.&lt;/li&gt;
&lt;li&gt;Avoiding nesting modules as far as possible, prefer a flat structure. For the purpose of demonstration,
I nested a module two levels deep.&lt;/li&gt;
&lt;li&gt;Intra package references &lt;a href=&#34;https://docs.python.org/3/tutorial/modules.html#intra-package-references&#34;&gt;info&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/tutorial/modules.html&#34;&gt;Official tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/Python/comments/1bbbwk/whats_your_opinion_on_what_to_include_in_init_py/&#34;&gt;Reddit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Functions in Python 3</title>
      <link>https://www.ploggingdev.com/2016/11/functions-in-python-3/</link>
      <pubDate>Sun, 13 Nov 2016 10:30:06 +0530</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2016/11/functions-in-python-3/</guid>
      <description>&lt;p&gt;A function is a named sequence of statements. Since a function is named, it is reusable. A simple function
example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def hello_function():
    &#39;&#39;&#39;This is where the function documentation goes&#39;&#39;&#39;
    print(&#39;Hello from function&#39;)

hello_function()
print(hello_function)
#output
Hello from function
&amp;lt;function hello_function at 0x7f34bc7db378&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;def&lt;/code&gt; keyword is used to define a function.&lt;/li&gt;
&lt;li&gt;It is followed by the function name, argument list(if any), and a
colon &lt;code&gt;:&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The function body is indented by 4 spaces.&lt;/li&gt;
&lt;li&gt;The first line of a function body is a
&lt;a href=&#34;https://docs.python.org/3/tutorial/controlflow.html#tut-docstrings&#34;&gt;docstring&lt;/a&gt;,
which is documentation for the function. It&amp;rsquo;s a good practice to always include the docstring.&lt;/li&gt;
&lt;li&gt;The statements that constitute the function are placed after the docstring.&lt;/li&gt;
&lt;li&gt;A function is an object, notice the output of &lt;code&gt;print(hello_function)&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;A function can return a value after it finishes execution. If a return value is not specified, the
default value is &lt;code&gt;None&lt;/code&gt;. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def function_with_return():
    &#39;&#39;&#39;This function returns a number&#39;&#39;&#39;
    return 42
return_value = function_with_return()
print(return_value)
#output
42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;return&lt;/code&gt; keyword is used to return a variable or value.&lt;/p&gt;

&lt;p&gt;A function can accept arguments. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def function_args(arg1):
    &#39;&#39;&#39;Prints the argument it recieves&#39;&#39;&#39;
    print(arg1)
function_args(&#39;My argument&#39;)
#output
My argument
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is possible to have default arguments. When an argument is not provided, a default value is used.
Example :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def function_default_args(arg1=42):
    &#39;&#39;&#39;A function with a default argument&#39;&#39;&#39;
    print(arg1)
function_default_args(34)
function_default_args()
#output
34
42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Keyword arguments are specified by explicitly stating which argument a value belongs to. Very poor
explanation, let the code speak:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def function_kwargs(name=&#39;no name&#39;, age=42):
    &#39;&#39;&#39;Keyword arguments demo&#39;&#39;&#39;
    print(name, &#39; &#39;, age)
function_kwargs(age=34,name=&#39;my name&#39;)
function_kwargs(name=&#39;my name&#39;,age=34)
#output
my name   34
my name   34
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is possible to mix keyword and positional arguments. Keyword arguments should always come after
positional arguments. The
&lt;a href=&#34;https://docs.python.org/3/tutorial/controlflow.html#keyword-arguments&#34;&gt;official ducumentation&lt;/a&gt; explains
this concept well.&lt;/p&gt;

&lt;p&gt;Arbitrary argument lists are those whose content length can vary. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def function_variable_args(*args):
    &#39;&#39;&#39;This function prints a variable number of arguments&#39;&#39;&#39;
    print(&#39; &#39;.join(*args))
variable_args1 = &#39;python&#39;, &#39;ruby&#39;, &#39;php&#39;
function_variable_args(variable_args1)
variable_args2 = &#39;python&#39;, &#39;ruby&#39;, &#39;php&#39;, &#39;java&#39;
function_variable_args(variable_args2)
#output
python ruby php
python ruby php java
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I don&amp;rsquo;t understand arbitrary argument lists well. The same result can be achieved by using a normal tuple
without the &lt;code&gt;*args&lt;/code&gt;. I&amp;rsquo;ll come back to this later.&lt;/p&gt;

&lt;p&gt;The official documentation also contains tl;dr about the coding style in Python. Link
&lt;a href=&#34;https://docs.python.org/3/tutorial/controlflow.html#intermezzo-coding-style&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To understand how arguments are passed to functions and how arguments being mutable or immutable
affects the values in the outer scope, refer
&lt;a href=&#34;http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Code for today&amp;rsquo;s plog is &lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/functions.py&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/tutorial/controlflow.html#defining-functions&#34;&gt;Official tutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Control flow tools in Python 3</title>
      <link>https://www.ploggingdev.com/2016/11/control-flow-tools-in-python-3/</link>
      <pubDate>Sat, 12 Nov 2016 11:28:34 +0530</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2016/11/control-flow-tools-in-python-3/</guid>
      <description>&lt;p&gt;Before I start with control flow tools, here are a few definitions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Value:&lt;/strong&gt; Basic units of data. Eg- &lt;code&gt;10&lt;/code&gt;,&lt;code&gt;&#39;string&#39;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Variable:&lt;/strong&gt; A name that refers to a value. Eg- &lt;code&gt;var=10&lt;/code&gt;, &lt;code&gt;var&lt;/code&gt; is the variable.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Statement:&lt;/strong&gt; A section of code that represents a command or action.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Operator:&lt;/strong&gt; A symbol that performs operations on operands. Eg- &lt;code&gt;*&lt;/code&gt; is for multiplication&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Expression&lt;/strong&gt; A combination of variables, operators, and values to perform a task.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To learn about operators in Python refer
&lt;a href=&#34;https://www.tutorialspoint.com/python3/python_basic_operators.htm&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Some of the control flow tools are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;if&lt;/code&gt; statement&lt;/li&gt;
&lt;li&gt;&lt;code&gt;while&lt;/code&gt; statement&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for&lt;/code&gt; statement&lt;/li&gt;
&lt;li&gt;&lt;code&gt;break&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt; and &lt;code&gt;pass&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;if&lt;/code&gt; statements are used for conditional decision making. Executution starts from &lt;code&gt;if&lt;/code&gt; then &lt;code&gt;elif&lt;/code&gt; and
finally &lt;code&gt;else&lt;/code&gt; statements. The first condition that matches (evaluates to &lt;code&gt;True&lt;/code&gt;) is executed and the
remaining conditions are skipped. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;num=42
if num&amp;gt;0:
    print(&#39;postive number&#39;)
elif num==0:
    print(&#39;Zero&#39;)
else:
    print(&#39;negative number&#39;)
#output
postive number
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;while&lt;/code&gt; statement is used for iteration. It consists of a condition, which evaluates to either &lt;code&gt;True&lt;/code&gt;
or &lt;code&gt;False&lt;/code&gt;. The code inside the &lt;code&gt;while&lt;/code&gt; loop is executed as long as the condition evaluates to &lt;code&gt;True&lt;/code&gt;.
Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(&#39;while example&#39;)
counter=10
while counter&amp;gt;0:
    print(counter)
    counter-=1
print(&#39;Blast off&#39;)
#output
while example
10
9
8
7
6
5
4
3
2
1
Blast off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;for&lt;/code&gt; loop is used to iterate over the items of any sequence such as lists, strings. Examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(&#39;for example 1&#39;)
values=[11,12,34,46]
for i in values:
    print(i)

print(&#39;for example 2&#39;)
for i in range(6):
    print(i)
#output
for example 1
11
12
34
46
for example 2
0
1
2
3
4
5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;continue&lt;/code&gt; statement is used to skip the current iteration of either a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;for&lt;/code&gt; loop. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(&#39;continue example&#39;)
for i in range(10):
    if(i%2==0):
        continue
    print(i)
#output
continue example
1
3
5
7
9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above example, even numbers are not printed.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;break&lt;/code&gt; statement is used to stop the execution of the loop that it is encountered in. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(&#39;break example&#39;)
for i in range(10):
    if(i==6):
        break
    print(i)
#output
break example
0
1
2
3
4
5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;code&gt;6&lt;/code&gt; is encountered, execution of the &lt;code&gt;for&lt;/code&gt; loop is stopped. Note that in the case of nested &lt;code&gt;for&lt;/code&gt;
loops, only the execution of the loop that &lt;code&gt;break&lt;/code&gt; is encountered in is stopped, but not the loops at a
higher level.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;pass&lt;/code&gt; statement does not do anything. It is generally used in situations where code is expected to
be present, but there is nothing meaningful that can be placed. The following example demonstrates the
usage of &lt;code&gt;pass&lt;/code&gt;, though it is not a good example of where to use &lt;code&gt;pass&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(&#39;pass example&#39;)
for i in range(10):
    pass
    print(i)
    pass
#output
pass example
0
1
2
3
4
5
6
7
8
9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/tutorial/controlflow.html&#34;&gt;Official tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/python3/python_basic_operators.htm&#34;&gt;Tutorials Point&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Code for today&amp;rsquo;s plog is
&lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/control_flow.py&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Dictionaries in Python 3</title>
      <link>https://www.ploggingdev.com/2016/11/dictionaries-in-python-3/</link>
      <pubDate>Fri, 11 Nov 2016 13:27:42 +0530</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2016/11/dictionaries-in-python-3/</guid>
      <description>&lt;p&gt;A dictionary is an unordered set of key-value pairs. A dictionary is indexed by keys, which can be
strings, integers or tuples. A dictionary is like an associative array, if you are familiar with
associative arrays from other programming languages.&lt;/p&gt;

&lt;p&gt;A dictionary can be created in multiple ways, using &lt;code&gt;{}&lt;/code&gt; or the &lt;code&gt;dict()&lt;/code&gt; function. The following are
some examples of ways to create dictionaries:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a=dict(one=1,two=2)
b={&#39;one&#39;:1,&#39;two&#39;:2}
c=dict(zip([&#39;one&#39;,&#39;two&#39;],[1,2]))
d=dict([(&#39;one&#39;,1),(&#39;two&#39;,2)])
e=dict({&#39;one&#39;:1,&#39;two&#39;:2})
print(a==b==c==d==e)
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, all the variables hold the same dictionary. To create an empty dictionary, use &lt;code&gt;{}&lt;/code&gt; or
 &lt;code&gt;dict()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; I will be using the syntax used to initialize variable &lt;code&gt;b&lt;/code&gt;, as it feels most natural to me.
It&amp;rsquo;s a personal preference, use whichever syntax you are comfortable with.&lt;/p&gt;

&lt;p&gt;There are multiple functions and methods that can be used to perform operations on dictionaries, some of
whose usage is shown in the following examples.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The operations are fairly straight forward to understand, so I won&amp;rsquo;t explain them in detail.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(&#39;Dictionary contents &#39;,a)
Dictionary contents  {&#39;two&#39;: 2, &#39;one&#39;: 1}

print(&#39;len(a) &#39;,len(a))
len(a)  2

print(&#39;a[\&#39;one\&#39;] &#39;,a[&#39;one&#39;])
a[&#39;one&#39;]  1

#changing value associated with &#39;one&#39; key
a[&#39;one&#39;]=11
print(&#39;Dictionary contents after a[\&#39;one\&#39;]=11 &#39;,a)
Dictionary contents after a[&#39;one&#39;]=11  {&#39;two&#39;: 2, &#39;one&#39;: 11}

a[&#39;one&#39;]=1
print(&#39;a[\&#39;one\&#39;]=1 &#39;,&#39;one&#39; in a)
a[&#39;one&#39;]=1  True

#in operator cannot be used to check the existence of values
print(&#39;1 in a &#39;,1 in a)
1 in a  False

#providing a default value if requested key does not exist
print(&#39;a.get(\&#39;three\&#39;,3) &#39;,a.get(&#39;three&#39;,3))
a.get(&#39;three&#39;,3)  3

print(&#39;a.keys() &#39;,a.keys())
a.keys()  dict_keys([&#39;two&#39;, &#39;one&#39;])

print(&#39;a.values() &#39;,a.values())
a.values()  dict_values([2, 1])

print(&#39;a.pop(\&#39;one\&#39;) &#39;,a.pop(&#39;one&#39;))
a.pop(&#39;one&#39;)  1

print(&#39;Dictionary contents &#39;,a)
Dictionary contents  {&#39;two&#39;: 2}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can read more about operations on dictionaries
&lt;a href=&#34;https://docs.python.org/3/library/stdtypes.html#mapping-types-dict&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The objects returned by &lt;code&gt;dict.keys()&lt;/code&gt;, &lt;code&gt;dict.values()&lt;/code&gt; and &lt;code&gt;dict.items()&lt;/code&gt; are &lt;em&gt;view&lt;/em&gt; objects. When the
contents of the dictionary changes, the changes are reflected in the &lt;em&gt;view&lt;/em&gt; objects. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(&#39;Dictionary contents &#39;,a)
Dictionary contents  {&#39;two&#39;: 2}

vals=a.values()
print(vals)
dict_values([2])

a[&#39;two&#39;]=22
print(vals)
dict_values([22])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/tutorial/datastructures.html#dictionaries&#34;&gt;Official tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/library/stdtypes.html#mapping-types-dict&#34;&gt;Official library reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The code for today&amp;rsquo;s plog is &lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/dictionaries.py&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Sets in Python 3</title>
      <link>https://www.ploggingdev.com/2016/11/sets-in-python-3/</link>
      <pubDate>Thu, 10 Nov 2016 09:21:40 +0530</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2016/11/sets-in-python-3/</guid>
      <description>&lt;p&gt;A set is an unordered collection with no duplicate elements. Sets are used for membership testing, removing
duplicate entries and performing set operations such as intersection, union and difference.&lt;/p&gt;

&lt;p&gt;There are two built-in set types: set and frozenset. The set type is mutable and the frozenset type is
immutable.&lt;/p&gt;

&lt;p&gt;Set construction:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;set()&lt;/code&gt; for empty set. &lt;strong&gt;Note:&lt;/strong&gt; {} cannot be used&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set(values)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{value1,valuen}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Construction of frozenset is very similar and uses &lt;code&gt;frozenset()&lt;/code&gt; instead of &lt;code&gt;set()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Set examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;myset1=set()
print(myset1)
set()

myset2=set(&#39;aaabbcc&#39;)
print(myset2)
{&#39;b&#39;, &#39;a&#39;, &#39;c&#39;}

myset3={&#39;python&#39;,&#39;java&#39;,&#39;c#&#39;,&#39;php&#39;}
print(myset3)
{&#39;c#&#39;, &#39;php&#39;, &#39;java&#39;, &#39;python&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Operators that can be used on sets and frozensets with example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#membership testing
print(&#39;python&#39; in myset3)
True

#find length
print(len(myset3))
4

myset4={&#39;python&#39;,&#39;c++&#39;}

#intersection
print(myset3.intersection(myset4))
{&#39;python&#39;}

#difference
print(myset3.difference(myset4))
{&#39;c#&#39;, &#39;php&#39;, &#39;java&#39;}

#union
print(myset3.union(myset4))
{&#39;php&#39;, &#39;python&#39;, &#39;c#&#39;, &#39;java&#39;, &#39;c++&#39;}

#add element to set
myset4.add(&#39;lisp&#39;)
print(myset4)
{&#39;c++&#39;, &#39;python&#39;, &#39;lisp&#39;}

#remove lement from set
myset4.remove(&#39;c++&#39;)
print(myset4)
{&#39;python&#39;, &#39;lisp&#39;}

#equality testing
print(myset3==myset4)
False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Operations that involve modification of set data such as &lt;code&gt;add()&lt;/code&gt; and &lt;code&gt;remove()&lt;/code&gt; cannot be used on frozensets.&lt;/p&gt;

&lt;p&gt;Code for today&amp;rsquo;s plog is &lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/sets.py&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/tutorial/datastructures.html#sets&#34;&gt;Official tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset&#34;&gt;Official library reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Ranges in Python 3</title>
      <link>https://www.ploggingdev.com/2016/11/ranges-in-python-3/</link>
      <pubDate>Wed, 09 Nov 2016 14:00:07 +0530</pubDate>
      <author>ploggingdev@gmail.com (Plogging Dev)</author>
      <guid>https://www.ploggingdev.com/2016/11/ranges-in-python-3/</guid>
      <description>&lt;p&gt;The range is an immutable sequence of numbers. The main advantage of using the range type is that the
memory occupied is fixed irrespective of the size of the range. This is because the actual contents of
the range are not stored, instead they are computed at runtime.&lt;/p&gt;

&lt;p&gt;Ranges can be created using:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;range(stop)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;range(start,stop)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;range(start,stop,step)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Only the 1st and 3rd are constructors. In &lt;code&gt;range(start,stop,step)&lt;/code&gt;, step is an optional
parameter. When step is not specified, what we end up with is &lt;code&gt;range(start,stop)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Quick notes about the arguments passed to &lt;code&gt;range()&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If &lt;code&gt;start&lt;/code&gt; is not specified, the default value is 0.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;step&lt;/code&gt; is not specified, the default value is 1.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;step&lt;/code&gt; value cannot be zero, a runtime error will be thrown.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;step&lt;/code&gt; value &lt;em&gt;can&lt;/em&gt; be negative.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Stop&lt;/code&gt; is always required to be specified.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;To check the values of a range, convert the range to a list and print the list. Printing a range
directly using &lt;code&gt;print(range_var)&lt;/code&gt; will not display the values in the range, since the values are not stored.&lt;/p&gt;

&lt;p&gt;Some examples to demonstrate the usage of ranges:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#range(stop)
r1=range(10)
print(list(r1))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

#range(start,stop)
r2=range(2,10)
print(list(r2))
[2, 3, 4, 5, 6, 7, 8, 9]

#range(start,stop,step)
r3=range(10,20,2)
print(list(r3))
[10, 12, 14, 16, 18]

#negative step value
r4=range(30,10,-5)
print(list(r4))
[30, 25, 20, 15]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To check if a value is present in a range, the &lt;code&gt;in&lt;/code&gt; operator can be used.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r5=range(10,20)
print(15 in r5)
True

print(25 in r5)
False 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The comparison operators &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; can be used to compare the values of different ranges.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(range(0,4,2)==range(0,3,2))
True

print(range(10)!=range(20))
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The source code for today&amp;rsquo;s plog is &lt;a href=&#34;https://github.com/ploggingdev/python_learn/blob/master/range.py&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>